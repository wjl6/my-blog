---
title: "001-MySQL-基础.md"
date: 2025-12-28 17:39:13
tags: []
---


## 一、MySQL 基础概念

### 1. MySQL 是什么？常见应用场景有哪些？

MySQL 是一种关系型数据库（RDBMS），基于 SQL 进行数据管理，广泛应用于：
- Web 系统
- 电商系统
- 内容管理系统
- 业务核心数据存储

---

### 2. MySQL 常见存储引擎有哪些？

| 存储引擎 | 事务支持 | 锁粒度 | 索引结构 | 数据恢复 | 外键支持 | 典型适用场景 |
|----------|----------|--------|----------|----------|----------|--------------|
| InnoDB   | ✅ 支持（ACID） | 行级锁 | B + 树（聚簇索引） | ✅ 支持（redo/undo 日志） | ✅ 支持 | 核心业务（订单、库存、支付）、高并发写、事务场景 |
| MyISAM   | ❌ 不支持 | 表级锁 | B + 树（非聚簇索引） | ❌ 仅修复（无事务日志） | ❌ 不支持 | 只读 / 少写场景（日志、报表、静态数据） |
| Memory   | ❌ 不支持 | 表级锁 | 哈希 / B + 树 | ❌ 重启丢失 | ❌ 不支持 | 临时缓存（会话数据、计数器、临时计算） |
| Archive  | ❌ 不支持 | 行级锁（仅插入） | 无（仅支持主键） | ✅ 支持 | ❌ 不支持 | 归档 / 日志存储（如监控日志、历史数据） |
| CSV      | ❌ 不支持 | 表级锁 | 无 | ✅ 支持（文本恢复） | ❌ 不支持 | 数据导入导出（与 Excel/CSV 交互） |
| NDB      | ✅ 支持（分布式事务） | 行级锁 | B + 树 | ✅ 支持 | ❌ 不支持 | 分布式集群（MySQL Cluster）、高可用场景 |

---

### 3. MySQL 的事务隔离级别有哪些？
MySQL 的事务隔离级别是为了解决**并发事务下**的 **脏读、不可重复读、幻读** 等**数据一致性问题**，定义了多个事务同时读写数据时的可见性规则。MySQL 基于 SQL 标准定义了 4 个隔离级别，且默认采用「**可重复读（RR）**」，并通过 InnoDB 引擎的 MVCC（多版本并发控制）+ 锁机制 实现

#### 并发事务会引发的核心问题（按严重程度排序）
| 问题类型 | 定义 | 示例 |
|----------|------|------|
| 脏读（Dirty Read） | 事务 A 读取到事务 B **未提交** 的数据，若 B 回滚，A 读取的是 “脏数据” | 事务 B 扣减库存（未提交），事务 A 读取到扣减后的库存，B 回滚后 A 数据错误 |
| 不可重复读（Non-Repeatable Read） | 事务 A 内多次读取同一数据，期间事务 B **修改并提交** 了该数据，导致 A 多次读取结果不一致 | 事务 A 第一次读库存 = 100，事务 B 扣减为 99 并提交，A 再次读库存 = 99 |
| 幻读（Phantom Read） | 事务 A 内多次执行同一查询（如统计订单数），期间事务 B **插入/删除了符合条件** 的数据，导致 A 查询结果行数变化 | 事务 A 统计订单数 = 10，事务 B 新增 1 条订单并提交，A 再次统计 = 11 |

#### MySQL 事务隔离级别（按一致性从低到高）
MySQL 支持 SQL 标准的 4 个隔离级别，级别越高，数据一致性越强，但并发性能越低（锁开销越大），核心规则与适用场景如下：

#### 1. 读未提交（Read Uncommitted, RU）
###### 核心规则
- 事务能读取到其他事务 **未提交** 的数据；
- 完全不解决脏读、不可重复读、幻读问题。

###### 适用场景
几乎无生产场景使用，仅用于对一致性无要求、极致追求性能的临时统计（如快速导出粗略数据）。

#### 2. 读已提交（Read Committed, RC）
###### 核心规则
- 事务只能读取到其他事务 **已提交** 的数据；
- 解决 **脏读**，但仍存在不可重复读、幻读。

###### 实现原理
InnoDB 通过 MVCC（多版本并发控制）实现：每次读取时获取最新的 “已提交版本” 数据，而非事务启动时的版本。

###### 适用场景
- 大多数互联网业务（如电商商品详情、用户信息查询）；
- 对 “不可重复读” 容忍度高，追求高并发性能的场景；
- Oracle、SQL Server 的默认隔离级别。

#### 3. **可重复读（Repeatable Read, RR）**
###### 核心规则（MySQL 默认级别）
- 事务内多次读取同一数据，结果始终一致（不受其他事务提交影响）；
- 解决 **脏读、不可重复读**，InnoDB 下可 **避免大部分幻读**（但非完全解决）。

###### 实现原理
1. **MVCC**：事务启动时生成一个 “快照版本”，后续读取均基于该快照，不读取其他事务新提交的数据；
2. **Next-Key Lock**：InnoDB 的行锁升级为 “行 + 间隙锁”，防止其他事务插入/删除符合条件的数据，从而避免幻读。

###### 关键特性（MySQL 独有的优化）
- 即使是 RR 级别，InnoDB 仍支持 **读写并行**（读不阻塞写，写不阻塞读），通过 MVCC 实现；
- 幻读仅在 “范围更新” 场景可能出现（如 `UPDATE stock SET num=0 WHERE num>10`），普通查询无幻读。

###### 适用场景
- 核心业务（订单、库存、支付）；
- 对数据一致性要求高，需避免不可重复读的场景（如下单时多次校验库存）。

#### 4. 串行化（Serializable）
###### 核心规则
- 最高隔离级别，所有事务 **串行执行**（加表级锁）；
- 解决所有并发问题（脏读、不可重复读、幻读），但并发性能极差。

###### 实现原理
- 对所有查询加 **表级锁**（即使是读操作），事务必须排队执行；
- 读操作会阻塞写操作，写操作也会阻塞读操作。

###### 适用场景
- 极少使用，仅用于对数据一致性要求极高的场景（如金融核心交易、对账）；
- 并发量极低的后台管理系统。

#### 隔离级别对比总览
| 隔离级别               | 脏读       | 不可重复读 | 幻读         | 并发性能 | 适用场景                 |
|------------------------|------------|------------|--------------|----------|--------------------------|
| 读未提交（RU）| ✅ 存在    | ✅ 存在    | ✅ 存在      | 最高     | 无生产场景               |
| 读已提交（RC）| ❌ 解决    | ✅ 存在    | ✅ 存在      | 高       | 互联网普通业务           |
| 可重复读（RR）| ❌ 解决    | ❌ 解决    | ❌ 基本解决  | 中       | 核心业务（MySQL 默认）|
| 串行化（Serializable） | ❌ 解决    | ❌ 解决    | ❌ 解决      | 最低     | 金融核心 / 低并发场景    |



---

## 二、事务基础

### 1. 什么是事务？

事务是**一组要么全部成功、要么全部失败的操作**。

---

### 2. 事务的四大特性（ACID）？

- **A** 原子性
- **C** 一致性
- **I** 隔离性
- **D** 持久性

---

## 三、索引基础（重点）

### 1. 什么是索引？为什么能加快查询？

索引是**帮助数据库快速定位数据的数据结构**，本质上减少扫描行数。

---

### 2. MySQL 索引底层结构是什么？

- InnoDB：**B+Tree**
- 支持范围查询
- 叶子节点存数据或主键

---

### 3. 主键索引和普通索引的区别？

| 类型 | 区别 |
|----|----|
| 主键索引 | 唯一 + 不为空 |
| 普通索引 | 可重复、可为空 |

---

### 4. 什么是聚簇索引？

- 数据和索引存储在一起
- InnoDB 主键索引就是聚簇索引

| 特征         | 聚簇索引（InnoDB）                          | 非聚簇索引（MyISAM）                        |
|--------------|---------------------------------------------|---------------------------------------------|
| 数据存储     | 索引叶子节点 = 数据行                       | 索引叶子节点 = 数据行的物理地址（偏移量）   |
| 表索引数     | 仅 1 个聚簇索引，多个二级索引               | 多个索引（结构相同，均指向数据地址）        |
| 物理排序     | 数据按聚簇索引顺序排列                     | 数据无固定顺序，索引独立存储                |
| 回表操作     | 二级索引查询需回表（查主键）                | 所有索引查询均需回表（查物理地址）          |
| 主键性能     | 主键查询极快（直接取数据）                  | 主键查询与普通索引无差异                    |

---

### 5. 一个表可以有几个聚簇索引？

**只能一个**。

---

### 6. 索引一定能提升性能吗？

不一定：
- 写多读少场景
- 索引维护成本高
- 低区分度字段

---

### 7. 联合索引的存储结构是怎样的？

- InnoDB 使用 B+Tree

- key = col1 + col2 + col3

- 先按 col1 排序，col1 相同再按 col2 …

---

### 8. 什么是最左前缀原则？

- 查询条件必须从索引最左列开始

- 可以连续跳过后面的列，但不能跳过中间列

- 不只是 WHERE，ORDER BY / GROUP BY 也受影响

```sql
INDEX idx(a,b,c)

WHERE a=1 AND b=2 AND c=3  -- ✅
WHERE a=1 AND c=3         -- ❌ 只能用到 a
```

---

### 9. 联合索引 (a,b,c)，下面哪些能用？

```sql
WHERE a=1
WHERE a=1 AND b=2
WHERE a=1 AND b>2 AND c=3
```
- 前两条可以完全使用
- 第三条只能用到 (a,b)

> ❗范围查询会终止索引匹配

---

### 10. 联合索引中范围查询为什么会“中断”？
联合索引的 “范围中断” 本质是**范围查询破坏了后续列的有序性**，导致数据库无法利用索引快速过滤。

核心应对策略：
- 索引列顺序：等值列在前，范围列在后；
- 查询优化：用 IN 替代枚举值范围，用覆盖索引减少回表；
- 场景权衡：高频范围列可单独建索引，或接受部分列索引失效。

> ❗索引中断后，后续的查询条件只能扫描中断前的结果集

---

### 11. 联合索引能同时用于 WHERE + ORDER BY 吗？

- 可以，但顺序要一致

- 排序方向必须一致（ASC / DESC）

```sql
INDEX(a,b)

WHERE a=1 ORDER BY b  -- ✅
WHERE a=1 ORDER BY c  -- ❌
```

---

### 12. 为什么 ORDER BY 有时会导致 filesort？

- 排序字段不符合索引顺序

- 混合排序方向

- 中间字段缺失

> filesort 不一定在磁盘，但一定是额外排序

---

### 13. 联合索引和多个单列索引有什么区别？

| 对比维度         | 联合索引（如 idx_a_b_c (a,b,c)）                                                                 | 多个单列索引（如 idx_a (a)、idx_b (b)、idx_c (c)）                                                                 |
|------------------|--------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------|
| 存储结构         | 单棵 B+ 树，按 a→b→c 顺序排序，所有列存储在同一索引树中                                           | 多棵独立 B+ 树，每棵树仅存储单列数据 + 主键，树之间无关联                                                           |
| 匹配规则         | 遵循 “最左匹配原则”，仅按最左前缀（a/a,b/a,b,c）匹配生效，范围列右侧失效                           | 无 “前缀” 限制，单列为条件即可匹配，但多列条件需依赖优化器 “索引合并”（OR/AND）                                     |
| 查询性能         | 1. 多列等值 / 前缀范围查询：高效（单树遍历，无需回表）；<br>2. 非前缀匹配：失效                     | 1. 单列查询：高效；<br>2. 多列查询：低效（索引合并需遍历多棵树 + 合并结果）；<br>3. 大概率走全表扫描                 |
| 空间占用         | 低（单棵树存储多列，仅需一份主键）| 高（多棵树重复存储主键，列越多空间占用倍数级增加）|
| 维护成本         | 低（仅维护一棵 B+ 树，插入 / 更新 / 删除仅需修改一个索引）| 高（维护多棵 B+ 树，每次数据变更需修改所有相关索引）|
| 覆盖索引         | 易实现（多列存储在同一索引，可直接返回查询字段，避免回表）| 难实现（单索引仅含一列，多列查询必回表）|

> ❗查询条件为多个单列索引的 AND/OR 组合时，若优化器判断 “索引合并的成本 < 全表扫描成本”时触发**索引合并**

---

### 14. 联合索引中 LIKE 能用索引吗？

- LIKE 'abc%' ✅

- LIKE '%abc' ❌
> 前缀匹配仍满足最左前缀原则
---

### 15. 什么是覆盖索引？

- 查询字段全部在索引中
- 不回表

---


## 四、SQL 基础

### 1. delete、truncate、drop 的区别？

| 特性         | DELETE                                      | TRUNCATE                                    | DROP                                        |
|--------------|---------------------------------------------|---------------------------------------------|---------------------------------------------|
| 操作对象     | 表中的「数据行」（保留表结构）| 表中的「所有数据行」（保留表结构）| 整个「表 / 数据库」（删除结构 + 数据）|
| 操作类型     | DML（数据操作语言）| DDL（数据定义语言）| DDL（数据定义语言）|
| 事务支持     | 支持（可回滚）| 不支持（不可回滚）| 不支持（不可回滚）|
| 锁机制       | 行级锁（InnoDB），逐行删除                  | 表级锁，清空数据（不逐行删）| 表级锁，删除表结构                          |
| 自增主键     | 自增值保留（如删完 id=100，新增从 101 开始） | 自增值重置（新增从 1 开始）| 表被删除，自增属性消失                      |
| WHERE 条件   | 支持（可精准删除部分数据）| 不支持（只能清空全表）| 无（删除整个对象）|
| 性能         | 慢（逐行删除，记录日志）| 快（直接清空数据页，不记录行日志）| 最快（删除表元数据）|
| 数据恢复     | 可通过事务回滚 / 二进制日志恢复              | 仅能通过备份恢复（无行日志）| 仅能通过备份 / 表结构恢复                   |
| 触发器       | 执行（删除行时触发 BEFORE/AFTER DELETE）| 不执行（跳过触发器）| 不执行（表被删除，触发器失效）|
| 适用引擎     | 所有引擎（InnoDB/MyISAM）| 仅 InnoDB/MyISAM（Archive 不支持）| 所有引擎                                    |

---

### 2. where 和 having 的区别？

- where：过滤行
- having：过滤分组结果
```sql
-- 表结构：product(id, category, price)
-- 正确写法：WHERE 筛单价，HAVING 筛聚合结果
SELECT category, SUM(price) AS total_price
FROM product
WHERE price > 100  -- 先筛单价>100的商品（分组前）
GROUP BY category
HAVING total_price > 1000; -- 再筛分组后总价>1000的分类
```

---

### 3. inner join / left join 区别？

- inner join：交集
- left join：左表全量

---

### 4. union 和 union all 区别？

| 特性         | UNION                                          | UNION ALL                                    |
|--------------|------------------------------------------------|----------------------------------------------|
| 去重逻辑     | 自动去除结果集中的重复行                       | 不做去重，保留所有行（包括重复行）|
| 排序操作     | 合并后会对结果集排序（默认按第一列升序）| 直接合并，无排序操作                          |
| 性能         | 慢（去重 + 排序需额外计算）| 快（仅简单合并，无额外开销）|
| 数据完整性   | 结果无重复，但可能丢失真实数据（如重复的合法记录） | 保留原始数据（包括重复行），结果更完整        |
| 使用场景     | 需合并无重复的结果集（如合并不同表的唯一数据）| 已知结果集无重复，或需保留重复行（如合并日志、统计全量数据） |
| 底层操作     | 先合并所有行 → 去重（哈希 / 排序去重） → 排序 → 返回 | 直接拼接多个结果集 → 返回                    |

---

## 五、锁 & 并发基础

### 1. MySQL 有哪些锁？

- 表锁
- 行锁
- 间隙锁
- Next-Key Lock

| 分类维度               | 具体类型                          | 核心特征                                   |
|------------------------|-----------------------------------|--------------------------------------------|
| 🔒 按粒度              | 表级锁、行级锁、页级锁           | 锁的覆盖范围（表 > 页 > 行）|
| 🔒 按操作              | 共享锁（S 锁）、排他锁（X 锁）| 读 / 写操作的锁类型（兼容 / 互斥）|
| 🔒 按意图              | 意向共享锁（IS）、意向排他锁（IX） | 表级锁的 “预申请”，避免表锁与行锁冲突       |
| 🔒 按算法（InnoDB）| Record Lock、Gap Lock、Next-Key Lock | 行锁的具体实现方式（解决幻读）|
| 🔒 按引擎              | MyISAM 锁、InnoDB 锁             | 引擎专属锁（MyISAM 仅表锁）|

---

### 2. 行锁一定是 InnoDB 才有吗？

是的，MyISAM 只有表锁。

---

### 3. 什么是死锁？如何避免？

死锁：多个事务互相等待资源。

死锁需满足「四大必要条件」（缺一不可），打破任一条件即可避免死锁：
- 互斥条件：锁资源只能被一个事务持有（如行级 X 锁）；
- 请求与保持条件：事务持有部分锁，同时请求其他事务持有的锁；
- 不可剥夺条件：锁不能被强制剥夺，只能由持有事务主动释放；
- 循环等待条件：多个事务形成锁的循环依赖（如 T1 等 T2 的锁，T2 等 T1 的锁）

> InnoDB 行为：自动检测死锁，回滚 “代价更小” 的事务（如修改行数更少的事务），释放锁资源

死锁的常见触发场景

除了「交叉加锁顺序不一致」，以下场景也易引发死锁：
- **高并发下多事务竞争同一批行锁**：如秒杀场景中，大量事务同时更新不同订单 + 同一库存行；
- **间隙锁（Gap Lock）导致的循环等待**：RR 隔离级别下，范围查询加间隙锁，多个事务插入同一间隙触发死锁；
- **长事务持有锁过久**：事务执行时间长（如包含慢查询、外部接口调用），持有的锁不释放，增加锁冲突概率；
- **无索引导致行锁升级为表锁**：表锁下多事务竞争，更容易形成循环等待。

避免方式：
- 统一加锁顺序
> 所有事务按固定的表顺序、行顺序加锁，彻底避免循环等待
- 减少事务时间
- 使用合理索引

---

## 六、常见误区

### 1. MySQL 可以存图片吗？

可以，但不推荐：
- 影响性能
- 建议存对象存储 + URL

---

### 2. varchar(255) 中的 255 是什么？

- 最大字符数
- 与字符集相关（utf8 / utf8mb4）

---

### 3. char 和 varchar 区别？

| char | varchar |
|----|----|
| 定长 | 变长 |
| 查询快 | 节省空间 |

---

### 4. timestamp 和 datetime 区别？

- timestamp：受时区影响
- datetime：不受时区影响

---

## 七、运维 & 实战基础

### 1. MySQL 如何做备份？

- mysqldump（逻辑）
- xtrabackup（物理）

---

### 2. MySQL 如何查看慢 SQL？

- slow_query_log
- EXPLAIN

---


### 3. 查询过程优化器?

| 优化器类型       | 英文缩写 | 核心决策依据                                                                 | 适用场景                                   | 代表数据库                                   |
|------------------|----------|------------------------------------------------------------------------------|--------------------------------------------|----------------------------------------------|
| 基于规则的优化器 | RBO      | 预定义的硬规则（如 “索引列优先过滤”“小表驱动大表”），按规则优先级选择执行计划 | 简单查询、固定场景，无成本计算             | MySQL 早期版本、Oracle 8i 及之前（现已淘汰） |
| **基于成本的优化器** | CBO      | 计算每个执行计划的 “成本”（基于统计信息：表行数、索引基数、数据分布、I/O 开销等），选择成本最低的计划 | 复杂查询、多表关联、大数据量场景           | MySQL 5.6+、PostgreSQL、Oracle 9i+、SQL Server |
| 混合优化器       | -        | 结合 RBO 做 “规则前置过滤”（如剔除明显低效的计划），再用 CBO 计算最优计划     | 兼顾规则的稳定性和成本的精准性             | 现代主流数据库（如 MySQL 8.0、Oracle 19c）   |

MySQL 查询优化器（Optimizer）是 MySQL 执行 SQL 时的 “大脑”，核心作用是**对输入的 SQL 语句进行分析、重写，并从众多可能的执行计划中选择 “成本最低” 的最优计划**，最终交给执行器执行。它是基于 “成本估算” 的优化器（Cost-Based Optimizer，CBO），而非基于规则（RBO）—— 即优先选择 “执行成本（IO/CPU/ 内存）最低” 的方案，而非 “语法上最符合规则” 的方案。

#### 一、 工作流程

#### 阶段 1：语法解析与预处理（Parser + Preprocessor）

- 语法解析：检查 SQL 语法是否合法，将 SQL 解析为 “抽象语法树（AST）”（如 SELECT * FROM user WHERE a=1 AND b=2 转换为树形结构）；
- 预处理：修正 / 补充 SQL，消除歧义，包括：
  - 验证表 / 列名是否存在；
  - 展开视图（将视图替换为底层查询）；
  - 简化常量表达式（如 a=1+2 简化为 a=3）；
  - 消除无效条件（如 a=1 AND 1=0 直接简化为 FALSE）；
  - 处理隐式类型转换（如 a='1' 转换为 a=1，可能导致索引失效）。

#### 阶段 2：逻辑优化（Logical Optimization）

- 核心是**重写查询**，不改变查询结果，仅优化逻辑

| 核心优化手段   | 示例                                                                 | 目的                                   |
|----------------|----------------------------------------------------------------------|----------------------------------------|
| 子查询优化     | 将 IN (子查询) 转换为 JOIN；将相关子查询改写为非相关子查询           | 避免子查询的多次执行，提升效率         |
| JOIN 重排      | 多表 JOIN 时，调整表的连接顺序（小表驱动大表）| 减少中间结果集大小，降低 IO 成本       |
| 条件下推（Push Down） | 将 WHERE 条件下推到存储引擎 / 子查询 / JOIN 左侧                     | 提前过滤数据，减少后续处理的数据量     |
| 聚合优化       | 将 GROUP BY + COUNT 转换为索引扫描（覆盖索引）；合并重复聚合         | 避免全表扫描，减少计算量               |
| 常量传播       | a=1 AND b=a+2 简化为 a=1 AND b=3                                     | 减少运行时计算，精准过滤               |
| 空值优化       | 消除 a IS NULL AND a=1 这类无效条件                                 | 减少无用的过滤步骤                     |

#### 阶段 3：物理优化（Physical Optimization）

在逻辑计划的基础上，生成 “物理执行计划”—— 即确定具体的执行方式（如用哪个索引、JOIN 用哪种算法、是否排序），核心是**成本估算 + 计划选择**：

###### 成本估算的核心依据
- 优化器通过 information_schema 中的统计信息计算成本，核心统计项：
    - table_rows：表的总行数；
    - data_length：表的数据总大小（页数量）；
    - index_cardinality：索引的基数（唯一值数量）；
    - avg_row_length：平均行大小；
    - index_length：索引的总大小。

###### 成本计算公式（简化）：
- 全表扫描成本 = 表的总页数 × 单页读取成本；
- 索引扫描成本 = 索引的页数 × 单页读取成本 + 回表页数 × 单页读取成本（覆盖索引无回表）。

###### 核心决策点
- 索引选择：对每个过滤条件，评估可用的索引（单列索引 / 联合索引 / 主键索引），计算 “使用索引的成本” 和 “全表扫描的成本”，选择成本更低的方式；
- JOIN 算法选择：支持 3 种 JOIN 算法，优化器根据数据量选择：
  - Nested Loop Join：小表驱动大表，适合小数据量（成本低）；
  - Hash Join：构建哈希表，适合大数据量（MySQL 8.0 后默认）；
  - Merge Join：先排序再合并，适合已排序的数据集；
- JOIN 顺序选择：多表 JOIN 时，优化器会尝试不同的表连接顺序（如 A JOIN B JOIN C → A JOIN C JOIN B），计算每种顺序的中间结果集大小，选择最小的；
- 排序方式选择：是否使用 “文件排序（filesort）”，或利用索引的有序性避免排序。


#### 阶段 4：生成执行计划

最终生成 “执行计划（Execution Plan）”，**可通过 EXPLAIN/EXPLAIN ANALYZE 查看**，执行器会按照该计划调用存储引擎（InnoDB/MyISAM）的接口执行 SQL。


---


### 4. 如何干预 / 调优查询优化器？

#### 更新统计信息（解决 “统计过时” 问题）
优化器依赖统计信息，若数据大幅变更（如批量插入 / 删除），需手动更新：
```sql
-- 更新单个表的统计信息
ANALYZE TABLE `user`;

-- 全局开启自动更新统计信息（默认开启）
SET GLOBAL innodb_stats_auto_recalc = ON;
```

#### 强制使用指定索引（FORCE INDEX）
```sql
-- 强制使用 idx_a_b 索引
SELECT * FROM `user` FORCE INDEX (idx_a_b) WHERE a=1 AND b=2;

-- 忽略某个索引
SELECT * FROM `user` IGNORE INDEX (idx_a) WHERE a=1;
```

#### 调整 JOIN 顺序（STRAIGHT_JOIN）
调整 JOIN 顺序（STRAIGHT_JOIN）：

```sql
-- 强制按 A → B → C 的顺序 JOIN
SELECT * FROM A STRAIGHT_JOIN B ON A.id=B.a_id STRAIGHT_JOIN C ON B.id=C.b_id WHERE ...;
```

#### 调整优化器参数
通过参数调整优化器的成本计算逻辑（谨慎使用，建议仅临时调试）：
```sql
-- 降低索引扫描的成本权重（让优化器更倾向于选索引）
SET optimizer_switch = 'index_merge_intersection=on,index_merge_union=on';

-- 调整页读取的成本系数（InnoDB）
SET innodb_page_cost = 1.0; -- 默认 1.0，值越小越倾向于索引扫描

-- 关闭某些优化规则（如子查询优化）
SET optimizer_switch = 'subquery_to_derived=off';
```

#### 重写 SQL（从根源优化）
比干预优化器更有效的方式是重写 SQL，让优化器更容易选到最优计划：
- 避免隐式类型转换（如 a='1' → a=1）；
- 将子查询改写为 JOIN；
- 拆分复杂查询（如多层子查询拆分为多个简单查询）；
- 用覆盖索引避免回表（如 SELECT a,b FROM user WHERE a=1，而非 SELECT *）。

---












































