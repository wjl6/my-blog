---
title: "001-MySQL-基础.md"
date: 2025-12-28 17:39:13
tags: []
---


## 一、MySQL 基础概念

### 1. MySQL 是什么？常见应用场景有哪些？

MySQL 是一种关系型数据库（RDBMS），基于 SQL 进行数据管理，广泛应用于：
- Web 系统
- 电商系统
- 内容管理系统
- 业务核心数据存储

---

### 2. MySQL 常见存储引擎有哪些？

| 存储引擎 | 事务支持 | 锁粒度 | 索引结构 | 数据恢复 | 外键支持 | 典型适用场景 |
|----------|----------|--------|----------|----------|----------|--------------|
| InnoDB   | ✅ 支持（ACID） | 行级锁 | B + 树（聚簇索引） | ✅ 支持（redo/undo 日志） | ✅ 支持 | 核心业务（订单、库存、支付）、高并发写、事务场景 |
| MyISAM   | ❌ 不支持 | 表级锁 | B + 树（非聚簇索引） | ❌ 仅修复（无事务日志） | ❌ 不支持 | 只读 / 少写场景（日志、报表、静态数据） |
| Memory   | ❌ 不支持 | 表级锁 | 哈希 / B + 树 | ❌ 重启丢失 | ❌ 不支持 | 临时缓存（会话数据、计数器、临时计算） |
| Archive  | ❌ 不支持 | 行级锁（仅插入） | 无（仅支持主键） | ✅ 支持 | ❌ 不支持 | 归档 / 日志存储（如监控日志、历史数据） |
| CSV      | ❌ 不支持 | 表级锁 | 无 | ✅ 支持（文本恢复） | ❌ 不支持 | 数据导入导出（与 Excel/CSV 交互） |
| NDB      | ✅ 支持（分布式事务） | 行级锁 | B + 树 | ✅ 支持 | ❌ 不支持 | 分布式集群（MySQL Cluster）、高可用场景 |

---

### 3. MySQL 的事务隔离级别有哪些？
MySQL 的事务隔离级别是为了解决**并发事务下**的 **脏读、不可重复读、幻读** 等**数据一致性问题**，定义了多个事务同时读写数据时的可见性规则。MySQL 基于 SQL 标准定义了 4 个隔离级别，且默认采用「**可重复读（RR）**」，并通过 InnoDB 引擎的 MVCC（多版本并发控制）+ 锁机制 实现

#### 并发事务会引发的核心问题（按严重程度排序）
| 问题类型 | 定义 | 示例 |
|----------|------|------|
| 脏读（Dirty Read） | 事务 A 读取到事务 B **未提交** 的数据，若 B 回滚，A 读取的是 “脏数据” | 事务 B 扣减库存（未提交），事务 A 读取到扣减后的库存，B 回滚后 A 数据错误 |
| 不可重复读（Non-Repeatable Read） | 事务 A 内多次读取同一数据，期间事务 B **修改并提交** 了该数据，导致 A 多次读取结果不一致 | 事务 A 第一次读库存 = 100，事务 B 扣减为 99 并提交，A 再次读库存 = 99 |
| 幻读（Phantom Read） | 事务 A 内多次执行同一查询（如统计订单数），期间事务 B **插入/删除了符合条件** 的数据，导致 A 查询结果行数变化 | 事务 A 统计订单数 = 10，事务 B 新增 1 条订单并提交，A 再次统计 = 11 |

#### MySQL 事务隔离级别（按一致性从低到高）
MySQL 支持 SQL 标准的 4 个隔离级别，级别越高，数据一致性越强，但并发性能越低（锁开销越大），核心规则与适用场景如下：

#### 1. 读未提交（Read Uncommitted, RU）
###### 核心规则
- 事务能读取到其他事务 **未提交** 的数据；
- 完全不解决脏读、不可重复读、幻读问题。

###### 适用场景
几乎无生产场景使用，仅用于对一致性无要求、极致追求性能的临时统计（如快速导出粗略数据）。

#### 2. 读已提交（Read Committed, RC）
###### 核心规则
- 事务只能读取到其他事务 **已提交** 的数据；
- 解决 **脏读**，但仍存在不可重复读、幻读。

###### 实现原理
InnoDB 通过 MVCC（多版本并发控制）实现：每次读取时获取最新的 “已提交版本” 数据，而非事务启动时的版本。

###### 适用场景
- 大多数互联网业务（如电商商品详情、用户信息查询）；
- 对 “不可重复读” 容忍度高，追求高并发性能的场景；
- Oracle、SQL Server 的默认隔离级别。

#### 3. **可重复读（Repeatable Read, RR）**
###### 核心规则（MySQL 默认级别）
- 事务内多次读取同一数据，结果始终一致（不受其他事务提交影响）；
- 解决 **脏读、不可重复读**，InnoDB 下可 **避免大部分幻读**（但非完全解决）。

###### 实现原理
1. **MVCC**：事务启动时生成一个 “快照版本”，后续读取均基于该快照，不读取其他事务新提交的数据；
2. **Next-Key Lock**：InnoDB 的行锁升级为 “行 + 间隙锁”，防止其他事务插入/删除符合条件的数据，从而避免幻读。

###### 关键特性（MySQL 独有的优化）
- 即使是 RR 级别，InnoDB 仍支持 **读写并行**（读不阻塞写，写不阻塞读），通过 MVCC 实现；
- 幻读仅在 “范围更新” 场景可能出现（如 `UPDATE stock SET num=0 WHERE num>10`），普通查询无幻读。

###### 适用场景
- 核心业务（订单、库存、支付）；
- 对数据一致性要求高，需避免不可重复读的场景（如下单时多次校验库存）。

#### 4. 串行化（Serializable）
###### 核心规则
- 最高隔离级别，所有事务 **串行执行**（加表级锁）；
- 解决所有并发问题（脏读、不可重复读、幻读），但并发性能极差。

###### 实现原理
- 对所有查询加 **表级锁**（即使是读操作），事务必须排队执行；
- 读操作会阻塞写操作，写操作也会阻塞读操作。

###### 适用场景
- 极少使用，仅用于对数据一致性要求极高的场景（如金融核心交易、对账）；
- 并发量极低的后台管理系统。

#### 隔离级别对比总览
| 隔离级别               | 脏读       | 不可重复读 | 幻读         | 并发性能 | 适用场景                 |
|------------------------|------------|------------|--------------|----------|--------------------------|
| 读未提交（RU）| ✅ 存在    | ✅ 存在    | ✅ 存在      | 最高     | 无生产场景               |
| 读已提交（RC）| ❌ 解决    | ✅ 存在    | ✅ 存在      | 高       | 互联网普通业务           |
| 可重复读（RR）| ❌ 解决    | ❌ 解决    | ❌ 基本解决  | 中       | 核心业务（MySQL 默认）|
| 串行化（Serializable） | ❌ 解决    | ❌ 解决    | ❌ 解决      | 最低     | 金融核心 / 低并发场景    |



---

## 二、事务基础

### 1. 什么是事务？

事务是**一组要么全部成功、要么全部失败的操作**。

---

### 2. 事务的四大特性（ACID）？

- **A** 原子性
- **C** 一致性
- **I** 隔离性
- **D** 持久性

---

## 三、索引基础（重点）

### 1. 什么是索引？为什么能加快查询？

索引是**帮助数据库快速定位数据的数据结构**，本质上减少扫描行数。

---

### 2. MySQL 索引底层结构是什么？

- InnoDB：**B+Tree**
- 支持范围查询
- 叶子节点存数据或主键

---

### 3. 主键索引和普通索引的区别？

| 类型 | 区别 |
|----|----|
| 主键索引 | 唯一 + 不为空 |
| 普通索引 | 可重复、可为空 |

---

### 4. 什么是聚簇索引？

- 数据和索引存储在一起
- InnoDB 主键索引就是聚簇索引

| 特征         | 聚簇索引（InnoDB）                          | 非聚簇索引（MyISAM）                        |
|--------------|---------------------------------------------|---------------------------------------------|
| 数据存储     | 索引叶子节点 = 数据行                       | 索引叶子节点 = 数据行的物理地址（偏移量）   |
| 表索引数     | 仅 1 个聚簇索引，多个二级索引               | 多个索引（结构相同，均指向数据地址）        |
| 物理排序     | 数据按聚簇索引顺序排列                     | 数据无固定顺序，索引独立存储                |
| 回表操作     | 二级索引查询需回表（查主键）                | 所有索引查询均需回表（查物理地址）          |
| 主键性能     | 主键查询极快（直接取数据）                  | 主键查询与普通索引无差异                    |

---

### 5. 一个表可以有几个聚簇索引？

**只能一个**。

---

### 6. 索引一定能提升性能吗？

不一定：
- 写多读少场景
- 索引维护成本高
- 低区分度字段

---

## 四、SQL 基础

### 1. delete、truncate、drop 的区别？

| 特性         | DELETE                                      | TRUNCATE                                    | DROP                                        |
|--------------|---------------------------------------------|---------------------------------------------|---------------------------------------------|
| 操作对象     | 表中的「数据行」（保留表结构）| 表中的「所有数据行」（保留表结构）| 整个「表 / 数据库」（删除结构 + 数据）|
| 操作类型     | DML（数据操作语言）| DDL（数据定义语言）| DDL（数据定义语言）|
| 事务支持     | 支持（可回滚）| 不支持（不可回滚）| 不支持（不可回滚）|
| 锁机制       | 行级锁（InnoDB），逐行删除                  | 表级锁，清空数据（不逐行删）| 表级锁，删除表结构                          |
| 自增主键     | 自增值保留（如删完 id=100，新增从 101 开始） | 自增值重置（新增从 1 开始）| 表被删除，自增属性消失                      |
| WHERE 条件   | 支持（可精准删除部分数据）| 不支持（只能清空全表）| 无（删除整个对象）|
| 性能         | 慢（逐行删除，记录日志）| 快（直接清空数据页，不记录行日志）| 最快（删除表元数据）|
| 数据恢复     | 可通过事务回滚 / 二进制日志恢复              | 仅能通过备份恢复（无行日志）| 仅能通过备份 / 表结构恢复                   |
| 触发器       | 执行（删除行时触发 BEFORE/AFTER DELETE）| 不执行（跳过触发器）| 不执行（表被删除，触发器失效）|
| 适用引擎     | 所有引擎（InnoDB/MyISAM）| 仅 InnoDB/MyISAM（Archive 不支持）| 所有引擎                                    |

---

### 2. where 和 having 的区别？

- where：过滤行
- having：过滤分组结果
```sql
-- 表结构：product(id, category, price)
-- 正确写法：WHERE 筛单价，HAVING 筛聚合结果
SELECT category, SUM(price) AS total_price
FROM product
WHERE price > 100  -- 先筛单价>100的商品（分组前）
GROUP BY category
HAVING total_price > 1000; -- 再筛分组后总价>1000的分类
```

---

### 3. inner join / left join 区别？

- inner join：交集
- left join：左表全量

---

### 4. union 和 union all 区别？

| 特性         | UNION                                          | UNION ALL                                    |
|--------------|------------------------------------------------|----------------------------------------------|
| 去重逻辑     | 自动去除结果集中的重复行                       | 不做去重，保留所有行（包括重复行）|
| 排序操作     | 合并后会对结果集排序（默认按第一列升序）| 直接合并，无排序操作                          |
| 性能         | 慢（去重 + 排序需额外计算）| 快（仅简单合并，无额外开销）|
| 数据完整性   | 结果无重复，但可能丢失真实数据（如重复的合法记录） | 保留原始数据（包括重复行），结果更完整        |
| 使用场景     | 需合并无重复的结果集（如合并不同表的唯一数据）| 已知结果集无重复，或需保留重复行（如合并日志、统计全量数据） |
| 底层操作     | 先合并所有行 → 去重（哈希 / 排序去重） → 排序 → 返回 | 直接拼接多个结果集 → 返回                    |

---

## 五、锁 & 并发基础

### 1. MySQL 有哪些锁？

- 表锁
- 行锁
- 间隙锁
- Next-Key Lock

| 分类维度               | 具体类型                          | 核心特征                                   |
|------------------------|-----------------------------------|--------------------------------------------|
| 🔒 按粒度              | 表级锁、行级锁、页级锁           | 锁的覆盖范围（表 > 页 > 行）|
| 🔒 按操作              | 共享锁（S 锁）、排他锁（X 锁）| 读 / 写操作的锁类型（兼容 / 互斥）|
| 🔒 按意图              | 意向共享锁（IS）、意向排他锁（IX） | 表级锁的 “预申请”，避免表锁与行锁冲突       |
| 🔒 按算法（InnoDB）| Record Lock、Gap Lock、Next-Key Lock | 行锁的具体实现方式（解决幻读）|
| 🔒 按引擎              | MyISAM 锁、InnoDB 锁             | 引擎专属锁（MyISAM 仅表锁）|

---

### 2. 行锁一定是 InnoDB 才有吗？

是的，MyISAM 只有表锁。

---

### 3. 什么是死锁？如何避免？

死锁：多个事务互相等待资源。

死锁需满足「四大必要条件」（缺一不可），打破任一条件即可避免死锁：
- 互斥条件：锁资源只能被一个事务持有（如行级 X 锁）；
- 请求与保持条件：事务持有部分锁，同时请求其他事务持有的锁；
- 不可剥夺条件：锁不能被强制剥夺，只能由持有事务主动释放；
- 循环等待条件：多个事务形成锁的循环依赖（如 T1 等 T2 的锁，T2 等 T1 的锁）

> InnoDB 行为：自动检测死锁，回滚 “代价更小” 的事务（如修改行数更少的事务），释放锁资源

死锁的常见触发场景

除了「交叉加锁顺序不一致」，以下场景也易引发死锁：
- **高并发下多事务竞争同一批行锁**：如秒杀场景中，大量事务同时更新不同订单 + 同一库存行；
- **间隙锁（Gap Lock）导致的循环等待**：RR 隔离级别下，范围查询加间隙锁，多个事务插入同一间隙触发死锁；
- **长事务持有锁过久**：事务执行时间长（如包含慢查询、外部接口调用），持有的锁不释放，增加锁冲突概率；
- **无索引导致行锁升级为表锁**：表锁下多事务竞争，更容易形成循环等待。

避免方式：
- 统一加锁顺序
> 所有事务按固定的表顺序、行顺序加锁，彻底避免循环等待
- 减少事务时间
- 使用合理索引

---

## 六、常见误区

### 1. MySQL 可以存图片吗？

可以，但不推荐：
- 影响性能
- 建议存对象存储 + URL

---

### 2. varchar(255) 中的 255 是什么？

- 最大字符数
- 与字符集相关（utf8 / utf8mb4）

---

### 3. char 和 varchar 区别？

| char | varchar |
|----|----|
| 定长 | 变长 |
| 查询快 | 节省空间 |

---

### 4. timestamp 和 datetime 区别？

- timestamp：受时区影响
- datetime：不受时区影响

---

## 七、运维 & 实战基础

### 1. MySQL 如何做备份？

- mysqldump（逻辑）
- xtrabackup（物理）

---

### 2. MySQL 如何查看慢 SQL？

- slow_query_log
- EXPLAIN

---