---
title: "002-Redis.md"
date: 2025-12-26 15:05:08
tags: []
---


### 1. Redis 为什么这么快？

核心原因：
- 内存存储
- 单线程模型（避免上下文切换）
- 高效数据结构
- I/O 多路复用

---

### 2. Redis 常用数据类型及场景？
| 类型         | 场景 | 底层实现数据结构            | 核心优势 | 典型时间复杂度 |
|------------|----|---------------------|----------|----------------|
| String     |  缓存 / 计数  | 简单动态字符串（SDS）        | 预分配空间，减少内存重分配；二进制安全 | O(1) |
| Hash       |  对象缓存  | 压缩列表（ziplist）→ 哈希表  | 数据量小时用 ziplist 节省内存；数据量大时自动转哈希表 | O(1) |
| List       |  消息队列  | 压缩列表 → 双向链表         | 两端操作（lpush/rpop）极快     | 两端 O(1)，中间 O(n) |
| Set        |  去重  | 整数集合（intset）→ 哈希表   | 整数元素用 intset 节省内存；自动扩容 | O(1) |
| Zset（有序集合） |  排行榜  | 压缩列表 → 跳表（skiplist） | 跳表支持范围查询，比红黑树实现更简单 | O(log n) |

> ZSet 是 Redis 中 “**有序 + 唯一**” 的核心数据结构，通过 score 实现灵活排序，底层跳表保证了高效的读写性能。其核心价值在于实时排序、范围查询、动态分值更新，是排行榜、延时队列、权重排序等场景的最优解。使用时需注意控制数据量、合理分页，避免全量遍历，以发挥其性能优势

---

### 3. Redis 过期策略？

#### 总结
Redis 过期策略的核心是 「惰性删除 + 定期删除」的组合：
- 惰性删除：CPU 友好，按需删除，避免无用功；
- 定期删除：内存友好，主动清理，避免内存泄漏；
- 内存淘汰机制：最后的兜底方案，解决内存不足的问题

#### （1） 惰性删除（Lazy Expiration）
**核心逻辑**：只有当用户主动访问某个键时，才会检查该键是否过期。如果过期，则删除该键并返回 nil；如果未过期，则正常返回键值。

**实现原理**：
1. 用户执行 `GET key` 命令；
2. Redis 检查 key 是否存在过期时间，且当前时间是否超过过期时间；
3. 若过期 → 删除该键，返回 nil；若未过期 → 返回键值。

**优势**：
- 对 CPU 友好：不需要额外的线程来扫描和删除过期键，只有在必要时才执行删除操作；
- 操作简单：逻辑清晰，实现成本低。

**劣势**：
- 对内存不友好：如果大量键过期但长期不被访问，这些键会一直占用内存，导致内存泄漏。

#### （2） 定期删除（Periodic Expiration）
**核心逻辑**：Redis 会启动一个定时任务，每隔一段时间主动扫描部分数据库，检查并删除过期键。

**触发时机**：Redis 主线程每隔 100ms（可通过 hz 配置调整）执行一次定期删除。

**实现原理**：
1. 每次定期删除时，随机选择 5 个数据库（Redis 默认有 16 个 db）；
2. 对每个选中的数据库，随机检查 20 个键；
3. 若键过期，则删除该键；
4. 如果本轮检查中，过期键的比例超过 25%，则重复步骤 2（继续检查该数据库的其他键），否则结束本轮检查。

**关键配置**：
- `hz 10`：默认每秒执行 10 次定期删除（即每 100ms 一次）；
- `hz` 值越大，定期删除越频繁，内存清理越及时，但对 CPU 消耗越高。

**优势**：
- 对内存友好：主动清理过期键，避免大量过期键占用内存；
- 性能可控：通过限制每次扫描的键数量和执行时长，避免阻塞主线程。

**劣势**：
- 可能存在漏删：无法保证所有过期键都被及时删除，仍需惰性删除兜底。

#### （3） 内存淘汰机制（Memory Eviction Policy）
当 Redis 内存使用达到 `maxmemory` 限制时，会触发内存淘汰机制，主动删除部分键来释放内存。这是过期策略的补充，用于解决「过期键未被及时删除 + 内存不足」的问题。

##### 内存淘汰机制的触发条件
- Redis 内存使用量 ≥ `maxmemory` 配置值；
- 执行写操作（如 SET、HSET）时，无法分配足够内存。

---

### 4. Redis 内存淘汰策略？

| 策略                       | 核心逻辑 | 适用场景 |
|--------------------------|----------|----------|
| volatile-lru             | 从设置了过期时间的键中，删除最近最少使用的键 | 大部分场景，兼顾性能和内存利用率 |
| volatile-ttl             | 从设置了过期时间的键中，删除过期时间最早的键 | 希望尽快删除即将过期的键 |
| volatile-random          | 从设置了过期时间的键中，随机删除部分键 | 对键的访问频率无要求的场景 |
| volatile-lfu（Redis 4.0+） | 从设置了过期时间的键中，删除最不常用的键 | 比 LRU 更精准，适合识别长期未使用的键 |
| allkeys-lru（常用）          | 从所有键中，删除最近最少使用的键 | 数据库中所有键都可能被淘汰的场景 |
| allkeys-random           | 从所有键中，随机删除部分键 | 对键的访问无规律的场景 |
| allkeys-lfu（Redis 4.0+）  | 从所有键中，删除最不常用的键 | 比 LRU 更适合识别冷数据 |
| noeviction（默认）           | 不删除任何键，拒绝所有写操作，返回错误 | 不允许数据丢失的场景（如金融数据） |


---

### 5. Redis 如何存储键的过期时间？如何快速判断键是否过期？

#### （1） 过期时间的存储
Redis 为每个数据库维护了一个 **过期字典（expires dict）**，键是数据库中的键，值是该键的过期时间戳（毫秒级）。
- 当执行 `EXPIRE key 10`（设置 10 秒过期）时，Redis 会将 `key` 和 `当前时间戳 + 10000` 存入过期字典；
- 当执行 `PERSIST key`（移除过期时间）时，Redis 会将 `key` 从过期字典中删除。

#### （2） 过期键的判断规则
判断一个键是否过期，遵循以下 3 条规则：
1. 如果键不存在于过期字典中 → 永不过期；
2. 如果键存在于过期字典中，但过期时间戳 > 当前时间戳 → 未过期；
3. 如果键存在于过期字典中，且过期时间戳 ≤ 当前时间戳 → 已过期。

---

### 6. 什么是缓存穿透 / 击穿 / 雪崩？

| 问题 | 场景                       | 解决方案                             |
|----|--------------------------|----------------------------------|
| 穿透 | 恶意攻击 / 查询不存在数据           | 布隆过滤器 / 数据库空值缓存                  |
| 击穿 | 热点 Key 失效                | 热点 key 永不过期 / 互斥锁 / 缓存预热         |
| 雪崩 | 大量 Key 同时失效 / Redis 集群宕机 | 过期时间随机 / 缓存集群高可用 / 多级缓存 / 服务降级限流 |

> 布隆过滤器是一种**空间效率极高的概率型数据结构**。它的核心作用是 快速判断一个元素是否存在于一个集合中，但代价是允许一定的 误判率（无法完全避免），且不支持删除操作
> 

---

### 7. Redis 如何保证缓存一致性？
Redis 保证缓存一致性的核心目标是 **「让缓存中的数据和数据库中的数据保持一致」**，避免出现「缓存有数据但数据库已更新」或「缓存无数据但数据库有数据」的矛盾场景

推荐方案：
- 旁路缓存模式 **「读走缓存，写走数据库，写后删缓存」**
- 设置合理 TTL
- MQ 重试删除缓存
- 读写并发时+分布式锁

> 最终一致性 指的是：缓存数据和数据库数据不会时刻完全一致，但经过一段有限的时间后，二者会自动达到一致状态

> 最终一致性 放弃了 “实时一致” 的要求，通过 “写数据库删缓存 + 缓存过期自动失效” 的组合策略，让缓存数据在一段有限时间后自动和数据库对齐，兼顾了性能和一致性
---

### 8. Redis 分布式锁如何实现？

#### (一) 分布式锁的核心要求
一个可靠的 Redis 分布式锁必须满足以下 4 个条件：
- 互斥性：同一时刻只能有一个客户端持有锁；
- 无死锁：即使持有锁的客户端崩溃，锁也能最终释放；
- 唯一性：锁只能被持有它的客户端释放，不能被其他客户端删除；
- 高可用：Redis 集群宕机时，锁服务仍能正常工作（可选，生产环境必备）。

#### （二） 基础实现：基于 SETNX + EXPIRE（入门版）
##### 1. 核心命令
- `SETNX key value`：「SET if Not Exists」，只有 key 不存在时才设置成功，返回 1；否则返回 0（实现互斥性）；
- `EXPIRE key seconds`：为 key 设置过期时间（避免死锁）。
##### 2. 核心问题（必须解决）
- **原子性问题**：SETNX 和 EXPIRE 是两条命令，若执行完 SETNX 后客户端崩溃，EXPIRE 未执行，锁会永久存在（死锁）；
- **解锁误删**：解锁时「查询锁」和「删除锁」是两条命令，若查询后锁过期自动释放，被其他客户端获取，此时删除的是别人的锁；
- **集群一致性**：Redis 主从切换时，主节点的锁未同步到从节点，导致从节点成为主节点后，锁丢失。


#### （三） 进阶实现：基于 SET 命令原子操作（工业级）
Redis 2.6.12+ 版本支持 SET 命令的扩展参数，可将「SETNX + EXPIRE」合并为一条原子命令，解决基础版的核心问题。
##### 1. 核心命令 （加锁实现-解决原子性问题）
```redis
SET lockKey clientId NX EX expireSeconds
```
- NX：等价于 SETNX，只有 key 不存在时才设置；
- EX：为 key 设置过期时间（秒），与 NX 组合成原子操作；
- clientId：客户端唯一标识（如 UUID + 线程 ID），用于解锁时校验归属。

##### 2.解锁实现（解决误删问题）
解锁的核心是「校验锁归属 + 删除锁」的原子性，需通过 Lua 脚本 实现（Redis 中 Lua 脚本执行是原子的）
```java
/**
 * 解锁方法（原子操作，避免误删）
 * @param lockKey 锁名称
 * @param clientId 加锁时返回的客户端标识
 * @return 是否解锁成功
 */
public boolean unlock(String lockKey, String clientId) {
    // Lua 脚本：先判断锁是否属于当前客户端，是则删除，否则返回 0
    String luaScript = """
            if redis.call('get', KEYS[1]) == ARGV[1] then
                return redis.call('del', KEYS[1])
            else
                return 0
            end
            """;
    // 执行 Lua 脚本
    Long result = (Long) redisTemplate.execute(
            new DefaultRedisScript<>(luaScript, Long.class),
            Collections.singletonList(lockKey),
            clientId
    );
    // result = 1 表示解锁成功，0 表示锁已过期/不属于当前客户端
    return result != null && result == 1;
}
```

#### （四） 高可用优化：RedLock 算法（集群场景）
上述方案仅适用于单 Redis 节点，若 Redis 主从切换 / 集群宕机，可能导致锁丢失。Redis 官方推荐 RedLock 算法 解决集群下的分布式锁问题。
##### 1. RedLock 核心逻辑
- 部署至少 3 个独立的 Redis 主节点（无主从），保证节点间完全独立；
- 客户端按以下步骤加锁：
> - 记录当前时间戳；
> - 依次向每个 Redis 节点发送 SET lockKey clientId NX EX expireSeconds 命令，超时时间远小于锁过期时间（如锁过期 30s，节点超时 5s）；
> - 计算加锁总耗时，若「成功加锁的节点数 ≥ 半数（如 3 节点需 ≥2）」且「总耗时 < 锁过期时间」，则加锁成功；
> - 若加锁失败，向所有节点发送解锁命令（即使节点未加锁成功）；
> - 解锁时，向所有 Redis 节点发送解锁脚本，确保所有节点的锁都被释放。
##### 2. RedLock 实现（基于 Redisson 框架）
生产环境无需手写 RedLock，可直接使用 Redis 官方推荐的 Redisson 框架（封装了完整的分布式锁实现，包括 RedLock）。
```java
// 1. 配置 Redisson 集群
Config config = new Config();
config.useRedLockServers()
        .addNodeAddress("redis://192.168.1.100:6379")
        .addNodeAddress("redis://192.168.1.101:6379")
        .addNodeAddress("redis://192.168.1.102:6379");
RedissonClient redisson = Redisson.create(config);

// 2. 获取 RedLock 锁
RLock lock1 = redisson.getLock("lock1");
RLock lock2 = redisson.getLock("lock2");
RLock lock3 = redisson.getLock("lock3");
RedissonRedLock redLock = new RedissonRedLock(lock1, lock2, lock3);

// 3. 加锁（等待 10s，锁过期 30s）
boolean locked = redLock.tryLock(10, 30, TimeUnit.SECONDS);
if (locked) {
    try {
        // 处理共享资源
    } finally {
        // 4. 解锁
        redLock.unlock();
    }
}
```

#### 核心点：
- set nx ex
- Lua 脚本
- Redisson

---


### 9. 如果锁过期了但任务未执行完该怎么办？
分布式锁最核心的坑点之一 —— **核心风险是锁失效后其他客户端会拿到锁，导致多个客户端同时执行同一任务，引发数据错乱、重复执行等问题**


- 问题根源：**锁的过期时间与任务执行时间不匹配**

#### 核心解决思路：分场景处理（从简单到复杂）
- 场景一：非核心任务（允许少量重复执行）→ 应急方案：延长过期时间

- 场景二：核心任务（绝对不允许并发执行）→ 工业级方案：锁续约（看门狗机制）
  这是解决该问题的最优方案，核心逻辑是：**让持有锁的客户端在任务执行过程中，定期给锁 “续命”（延长过期时间），直到任务完成再主动释放锁**

Redis 官方推荐的 Redlock 算法、Java 客户端（如 Redisson）都内置了这个机制（叫「看门狗 Watch Dog」），下面拆解实现逻辑

```java
Config config = new Config();
config.useSingleServer().setAddress("redis://127.0.0.1:6379");
RedissonClient redisson = Redisson.create(config);

// 获取分布式锁（默认开启看门狗，初始过期时间30s，每10s续约一次）
RLock lock = redisson.getLock("lockKey");
try {
    // 加锁（waitTime：最多等10s获取锁，leaseTime：-1表示用看门狗自动续约）
    boolean locked = lock.tryLock(10, -1, TimeUnit.SECONDS);
    if (locked) {
        // 执行核心任务（即使执行超过30s，看门狗会自动续约）
        doBusinessTask();
    }
} catch (InterruptedException e) {
    Thread.currentThread().interrupt();
} finally {
    // 任务完成后主动释放锁（若客户端宕机，看门狗停止，锁30s后自动过期）
    if (lock.isHeldByCurrentThread()) {
        lock.unlock();
    }
}
```

- 场景 3：超长时间任务（执行时间小时级）→ 拆分任务 + 分段锁


- 场景 4：极致严谨场景（金融 / 支付）→ 分布式锁 + 幂等性保障
即使做了锁续约，仍可能出现极端情况（比如客户端网络闪断，看门狗无法续约），此时需要双重保障
    - 分布式锁：保证 “大概率” 互斥；
    - 幂等性：保证 “即使并发执行，也不会重复处理数据”。



---

### 9. Redisson 的优势？
Redisson 的核心价值是「**将 Redis 的分布式能力封装为开发者友好的 Java API**」
- 核心优势 1：开箱即用的分布式原语，无需手写底层逻辑
- 核心优势 2：分布式锁的全维度优化，解决手写锁的所有痛点
- 核心优势 3：高可用性与容错能力，适配生产环境复杂场景
- 核心优势 4：高性能与易用性，兼顾效率与开发体验
- 核心优势 5：高级特性加持，拓展 Redis 适用场景

---
