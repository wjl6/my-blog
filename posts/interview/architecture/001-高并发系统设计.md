---
title: "001-高并发系统设计.md"
date: 2025-12-28 15:45:02
tags: []
---

## 1. 什么是高并发？核心难点是什么？

### 一、 什么是高并发？
高并发是指系统在单位时间内需要处理海量的请求（或任务），通常用 **QPS（每秒查询数）、TPS（每秒事务数）、并发用户数** 三个指标衡量，核心是在高请求压力下，系统仍能保持稳定、低延迟、高可用的服务能力。

#### 1. 量化指标（以互联网系统为例）
| 指标 | 含义 | 低并发 | 中高并发 | 超高并发 |
|------|------|--------|----------|----------|
| QPS | 每秒处理的查询请求数 | ＜ 100 | 1000 ~ 10000 | ＞ 10 万（如电商秒杀、双 11） |
| TPS | 每秒处理的事务数（含写操作） | ＜ 50 | 500 ~ 5000 | ＞ 1 万（如订单创建、支付） |
| 并发用户数 | 同时在线并发起请求的用户数 | ＜ 100 | 1 万～10 万 | ＞ 100 万（如社交平台峰值） |

### 2. 高并发的核心特征
- **请求密集**：单位时间内请求量远超系统常规负载；
- **资源竞争**：CPU、内存、磁盘 I/O、网络带宽、数据库连接等资源被大量抢占；
- **强实时性**：用户对响应延迟敏感（如秒杀场景要求 100ms 内响应）；
- **高可用要求**：不允许单点故障，需保证 99.9% 以上的服务可用性。

### 二、 高并发的核心难点
高并发的难点本质是 **「有限的系统资源」与「无限的用户请求」** 之间的矛盾，具体体现在 **资源瓶颈、数据一致性、系统稳定性、峰值应对** 四个维度，每个维度都存在技术挑战：

#### 1. 难点 1：资源瓶颈 —— 系统硬件 / 软件资源的极限约束
系统的处理能力最终受限于底层资源，高并发下资源瓶颈会被无限放大：
- **CPU 瓶颈**：
  高并发下大量线程上下文切换、锁竞争（如 `synchronized` 锁）会导致 CPU 利用率飙升至 100%，但有效计算占比极低；
  复杂计算（如数据聚合、全文检索）会占用大量 CPU 时间片，导致请求排队。
  典型问题：系统响应延迟陡增，出现 CPU 负载过高告警。

- **内存瓶颈**：
  缓存穿透 / 击穿 / 雪崩会导致大量请求穿透到数据库，同时缓存服务器内存溢出（OOM）；
  JVM 堆内存不足、GC 频繁（尤其是 Full GC）会导致系统停顿，无法处理请求。
  典型问题：服务进程崩溃、OOM 异常、GC 耗时过长。

- **磁盘 I/O 瓶颈**：
  数据库频繁写操作（如订单入库）会导致磁盘随机 I/O 飙升，机械硬盘的 I/O 性能极限约为 100 ~ 200 IOPS，远无法满足高并发写需求；
  日志、文件的大量读写会抢占磁盘带宽，导致数据库、缓存等核心服务 I/O 阻塞。

- **网络瓶颈**：
  服务器网卡带宽被打满（如 1G 网卡每秒最多处理约 100MB 数据），导致请求无法进出；
  网络延迟、丢包会导致分布式系统中节点间通信超时，引发重试风暴。

#### 2. 难点 2：数据一致性 —— 分布式场景下的数据正确性保障
高并发系统通常是分布式架构（多实例、多数据库），数据一致性是最大的技术坑：
- **分布式事务问题**：
  跨服务 / 跨数据库的操作（如「扣库存 → 生成订单 → 减余额」）无法用单机事务保证，若采用 2PC 协议会导致性能低下，采用最终一致性则可能出现数据不一致（如库存扣了但订单没生成）。
  典型场景：电商订单创建、支付转账。

- **缓存与数据库一致性**：
  缓存更新策略不当（如先更数据库再更缓存）会导致缓存脏数据；
  并发写场景下，多个请求同时更新缓存 / 数据库，会出现数据覆盖、版本冲突。

- **分布式锁问题**：
  分布式锁实现不当（如 Redis 锁未续期、ZooKeeper 锁性能低）会导致锁失效，引发超卖、重复下单等严重问题；
  锁粒度太粗会导致并发性能下降，粒度太细则增加系统复杂度。

#### 3. 难点 3：系统稳定性 —— 避免雪崩效应与服务降级失控
高并发下，系统的脆弱性会被放大，一个小问题可能引发连锁反应：
- **雪崩效应**：
  单个服务节点宕机 → 负载均衡将请求转发到其他节点 → 其他节点因压力过大也宕机 → 最终整个服务集群崩溃；
  典型场景：缓存雪崩导致数据库压力骤增，数据库宕机后引发整个电商系统瘫痪。

- **服务降级 / 熔断的权衡**：
  降级规则设计不当（如降级核心功能）会导致用户体验极差；
  熔断阈值设置不合理（如阈值太低导致正常请求被熔断，阈值太高无法保护系统）；
  难点：如何在保证核心功能可用和保护系统不被压垮之间找到平衡。

- **流量削峰的挑战**：
  秒杀、抢购等场景的流量是脉冲式峰值（瞬时 QPS 是平时的 100 倍），直接打到系统会导致瞬间崩溃；
  削峰方案（如队列、排队、预扣库存）的设计复杂，需考虑队列满了怎么办、排队超时如何处理等问题。

#### 4. 难点 4：峰值应对 —— 无法预测的流量波动
高并发系统的流量往往是不可预测的，比如热点事件、促销活动会导致流量突然飙升，核心难点在于：
- **容量评估难**：
  无法准确预测峰值流量，扩容太早会浪费资源，扩容太晚则无法应对峰值；
  分布式系统的容量评估需要考虑木桶效应（系统性能由最弱的组件决定，如数据库、缓存）。

- **弹性伸缩难**：
  云服务器的弹性伸缩需要时间（分钟级），无法应对秒级的流量峰值；
  伸缩策略需精准匹配业务流量（如根据 CPU 利用率、QPS 自动扩容 / 缩容），否则会导致伸缩震荡（频繁扩容缩容）。

- **热点问题**：
  热点数据：如某款秒杀商品的 ID 被大量请求，导致缓存服务器的某个分片压力过大（数据倾斜）；
  热点接口：如首页接口、登录接口被频繁调用，成为系统瓶颈；
  难点：如何快速发现并隔离热点，避免热点扩散导致全系统压力过大。

### 三、 高并发的核心解决思路（总结）
解决高并发问题的核心是 **「避峰、削峰、填谷、扩容、优化」**：
1. **避峰**：通过业务设计分散流量（如错峰促销、预约抢购）；
2. **削峰**：用队列、缓存、限流等手段平滑流量峰值；
3. **填谷**：利用异步化、批处理提升资源利用率；
4. **扩容**：水平扩容（增加节点）而非垂直扩容（升级硬件），突破单机瓶颈；
5. **优化**：从代码、SQL、缓存、JVM 等层面优化，提升单机处理能力。

---

## 2. 高并发系统的通用设计原则？

四个关键词：
- **限流**
- **缓存**
- **异步**
- **拆分**

---

## 3. 如何做系统限流？

常见方案：
- Nginx 限流
- 接口限流（令牌桶 / 漏桶）
- 网关限流

---

## 4. 如何应对流量突增（削峰填谷）？

- MQ 异步化
- 队列缓冲
- 拒绝非核心请求

---

## 5. 高并发下库存扣减如何设计？
高并发下直接操作数据库会导致性能瓶颈，必须采用 「**缓存层预扣减 → 数据库层最终扣减 → 异步兜底校验**」 的分层架构，兼顾性能和一致性。
```text
用户下单 → 1.缓存层预扣减 → 2.分布式锁（乐观锁）兜底 → 3.数据库层预占库存 → 4.订单创建成功 → 5.数据库层扣减物理库存 → 6.订单超时/取消 → 7.释放预占库存
```

---

## 6. 如何防止超卖？
防止超卖的核心是「**保证库存扣减的原子性、唯一性和一致性**」，需从「数据库层、应用层、架构层」三层防护，其中数据库层的原子性控制是根本。

### 核心原理：为什么会超卖？
「查库存 + 扣库存」是两步操作，非原子性，并发下多个请求会同时读到「库存充足」，然后同时扣减，最终库存为负
```java
// 错误示例：先查库存，再扣减，非原子操作
public boolean reduceStock(Long productId, int num) {
    // 1. 查询当前库存（并发下，多个请求会读到相同的库存值）
    Integer stock = jdbcTemplate.queryForObject(
        "SELECT stock FROM product WHERE id = ?",
        Integer.class, productId
    );
    // 2. 判断库存是否充足（并发下，多个请求都能通过此判断）
    if (stock < num) {
        return false;
    }
    // 3. 扣减库存（并发下，多个请求同时执行，导致库存为负）
    jdbcTemplate.update(
        "UPDATE product SET stock = stock - ? WHERE id = ?",
        num, productId
    );
    return true;
}
```

### 基础方案：数据库层原子控制（最核心，必做）
- 方案 1：UPDATE 语句加库存判断（推荐，最简单）  
将「查库存 + 扣库存」合并为一条 SQL，利用数据库的行锁实现原子性：
```sql
-- 核心 SQL：扣减库存时直接判断库存是否充足，返回受影响行数
UPDATE product
SET stock = stock - #{num}
WHERE id = #{productId} AND stock >= #{num};
```

- 方案 2：悲观锁（适合低并发、强一致性场景）  
  高并发下会导致请求排队，性能较低，仅适合库存变更频率低的场景

- 方案 3：乐观锁（适合高并发、允许重试场景）  
基于版本号 / 库存版本控制，解决并发扣减冲突，避免锁等待：

```java
// 最大重试次数
private static final int MAX_RETRY = 3;

public boolean reduceStockWithOptimisticLock(Long productId, int num) {
    int retryCount = 0;
    while (retryCount < MAX_RETRY) {
        try {
            // 1. 查询当前库存和版本号
            Map<String, Object> result = jdbcTemplate.queryForMap(
                "SELECT stock, version FROM product WHERE id = ?",
                productId
            );
            Integer stock = (Integer) result.get("stock");
            Integer version = (Integer) result.get("version");
            
            // 2. 判断库存
            if (stock < num) {
                return false;
            }
            
            // 3. 乐观锁更新
            int affectedRows = jdbcTemplate.update(
                "UPDATE product SET stock = stock - ?, version = version + 1 WHERE id = ? AND version = ?",
                num, productId, version
            );
            
            // 4. 更新成功则返回，失败则重试
            if (affectedRows > 0) {
                return true;
            }
            retryCount++;
            // 重试前短暂休眠，避免高频重试
            Thread.sleep(10);
        } catch (Exception e) {
            retryCount++;
        }
    }
    // 重试多次失败，返回库存不足
    return false;
}
```
> 无锁等待，高并发下性能优于悲观锁；  
> 适合秒杀、抢购等高频库存变更场景；  
> 缺点：冲突严重时会有重试开销，需设置合理的重试次数。

### 应用层防护（辅助，减少无效请求）

#### 1.库存预校验（前端 + 网关）  
- 前端：点击「下单」按钮后先校验库存（调用库存查询接口），库存不足直接提示，不发起下单请求；
- 网关层（如 Spring Cloud Gateway）：拦截秒杀请求，先查询缓存中的库存，库存≤0 时直接返回，不转发到业务服务。

#### 2. 分布式锁（防止多实例并发问题）   
如果应用部署多实例，需用 Redis/Zookeeper 分布式锁保证库存扣减的唯一性

#### 3. 限流熔断（控制并发量）
通过 Sentinel/Hystrix 限制库存扣减接口的并发量，避免请求过载导致超卖



---

### 四、架构层防护（高并发场景进阶）
#### 1. 库存缓存化（Redis 预扣减）
高并发秒杀场景下，**先扣减 Redis 缓存库存，再异步同步到数据库**：
```java
public boolean reduceStockWithRedis(Long productId, int num) {
    String stockKey = "product:stock:" + productId;
    // 1. Redis 原子扣减（INCRBY 负数）
    Long remainStock = redisTemplate.opsForValue().increment(stockKey, -num);
    // 2. 扣减后库存≥0则成功，否则回滚
    if (remainStock >= 0) {
        // 3. 异步更新数据库（消息队列）
        rabbitTemplate.convertAndSend("stock.update.queue", new StockUpdateMsg(productId, num));
        return true;
    } else {
        // 库存不足，回滚 Redis 扣减
        redisTemplate.opsForValue().increment(stockKey, num);
        return false;
    }
}

// 消费者：异步更新数据库
@RabbitListener(queues = "stock.update.queue")
public void handleStockUpdate(StockUpdateMsg msg) {
    // 执行数据库库存扣减（方案1的UPDATE语句）
    reduceStock(msg.getProductId(), msg.getNum());
}
```
- Redis 性能远高于数据库，能支撑每秒数万次的库存扣减；
- 异步同步数据库，避免高并发压垮数据库；
- **需处理 Redis 与数据库的数据一致性**（如**定时对账、补偿机制**）。

#### 2. 消息队列削峰（控制扣减速率）
将库存扣减请求放入消息队列（RabbitMQ/Kafka），消费端匀速处理，避免数据库压力过大：

### 总结
| 场景               | 推荐方案                                   | 并发能力   | 一致性   |
|--------------------|--------------------------------------------|------------|----------|
| 普通电商（低并发） | 数据库 UPDATE 原子扣减                     | QPS 1000+  | 强一致   |
| 常规秒杀（中并发） | 乐观锁 + Redis 缓存                        | QPS 5000+  | 最终一致 |
| 高并发秒杀（高并发） | Redis 预扣减 + 消息队列 + 数据库异步同步   | QPS 10 万 + | 最终一致 |
| 金融级库存（强一致） | 悲观锁 + 分布式事务                        | QPS 500+   | 强一致   |

---

## 7. 高并发下如何保证接口幂等？

常见手段：
- 唯一业务 ID
- Redis 去重
- 数据库唯一索引

---

## 8. 高并发系统如何拆分？

- 按业务域拆分（推荐）
- 读写分离
- 热点数据隔离

---

## 9. 如何让防止用户重复下单？

在高并发系统中，防止用户重复下单的核心思路是 「**前端拦截 + 后端幂等校验 + 数据库唯一约束 + 业务规则校验**」 四层防护体系，从源头到存储层全方位杜绝重复订单，同时保证用户体验和系统一致性。

### 重复下单的常见场景
- 前端误操作：用户快速点击多次「提交订单」按钮；
- 网络延迟：用户提交后未及时收到响应，刷新 / 重试页面；
- 接口重试：前端请求超时后自动重试，或第三方渠道重复回调；
- 高并发竞态：多线程同时处理同一用户的下单请求。

### 四层防护体系：防止重复下单

#### 1. 第一层：前端拦截（成本最低，源头限流）

- 按钮置灰 / 防抖   
  点击「提交订单」后立即禁用按钮，显示「处理中」，直到请求返回结果

- 生成唯一下单 Token	  
  进入下单页时，前端先向后端获取一次性 Token，下单时携带 Token，后端验证后立即失效

- 页面跳转防刷新	  
  下单成功后立即跳转支付页，禁用浏览器返回按钮（或返回后清空表单）

#### 2. 第二层：后端幂等性校验（核心防线，拦截重复请求）

- 方案 1：基于一次性 Token 的幂等校验（推荐）
  - 前端进入下单页时，后端生成唯一 Token（如 UUID），关联用户 ID 和商品信息，存入 Redis（有效期 5 分钟）；
  - 前端下单时携带 Token；
  - 后端验证 Token 有效性：存在则继续下单，且验证后立即删除 Token（防止重复使用）；不存在则直接返回「重复下单」。

- 方案 1：基于请求唯一 ID 的幂等校验（适合接口重试场景）
  - 核心逻辑：前端生成唯一请求 ID（如 UUID），每次下单携带该 ID；后端用 请求 ID + 用户 ID 作为 Redis Key，存在则拒绝，不存在则处理。
  - 适用场景：前端请求超时后自动重试，或第三方系统回调下单接口。

#### 3. 第三层：数据库唯一约束（兜底防线，杜绝脏数据）
即使前端和后端校验失效，数据库层面的唯一约束能最终拦截重复订单，避免数据不一致。

- 创建唯一索引：针对 user_id + product_ids + create_time 组合创建唯一索引，限制同一用户短时间内重复下单同一商品

#### 4. 第四层：业务规则校验（精细化限流，避免恶意下单）
结合业务场景设置限流规则，防止用户恶意刷订单，同时提升用户体验

- 用户级限购	  
 限制同一用户单位时间内的下单次数（如 10 分钟内最多 3 单）

- 商品级限购   
限制同一用户对同一商品的下单次数（如单个商品每天最多 1 单）

- 订单状态校验  
同一用户存在「未支付」订单时，禁止下单同一商品

---

## 10. 如何让防止用户重复支付？

「前端交互→后端校验→渠道调用→回调处理→状态更新→异常兜底」

在高并发订单系统中，防止用户重复支付的核心是 「**分布式锁 + 幂等性设计 + 状态机控制 + 异步校验**」 四层防护体系，既要避免用户因网络延迟、误操作导致的重复提交，也要防止高并发下系统内部的重复处理

### 用户重复支付的常见场景：
- 前端误操作：用户快速点击多次「支付」按钮；
- 网络延迟：用户支付后，前端未及时收到回调，重复发起请求；
- 系统重试：支付回调因网络抖动超时，第三方支付平台重复推送通知；
- 高并发竞态：多线程同时处理同一订单的支付请求。

### 四层防护体系：防止重复支付
#### 1. 第一层：前端拦截（成本最低，第一道防线）
从源头减少重复请求，适合非恶意用户的误操作场景。

| 措施                 | 实现方式                                                                 | 作用                                   |
|----------------------|--------------------------------------------------------------------------|----------------------------------------|
| 按钮置灰 / 禁用      | 点击「支付」后，立即将按钮置灰并显示「处理中」，直到请求返回结果         | 防止用户快速重复点击                   |
| 防重复提交 Token     | 生成唯一 Token 存入前端（如 localStorage），提交时携带 Token，后端验证后立即失效 | 防止页面刷新 / 回退后的重复提交         |
| 跳转支付页防抖       | 限制单位时间内（如 5 秒）只能发起一次支付请求                           | 避免短时间内多次跳转支付网关           |

#### 2.  第二层：后端幂等性校验（核心防线，解决重复请求）
幂等性：同一请求被多次提交时，执行结果一致，不会产生副作用（如重复扣款）。

| 方案                 | 实现原理                                                                 | 适用场景               | 优缺点                                                 |
|----------------------|--------------------------------------------------------------------------|------------------------|--------------------------------------------------------|
| **订单状态机控制**       | 订单支付状态设计为：待支付 → **支付中** → 支付成功/失败，只有 待支付 状态才能发起支付 | 所有订单支付场景       | 优点：简单高效，无额外存储；缺点：依赖状态机的严格校验 |
| 分布式锁 + 唯一请求 ID | 1. 前端生成唯一请求 ID（如 UUID）；2. 后端用 订单 ID + 请求 ID 作为锁 Key，加锁后校验订单状态；3. 处理完成后释放锁 | 高并发支付请求         | 优点：彻底避免并发竞态；缺点：依赖分布式锁的可靠性     |
| 幂等性 Token 校验    | 1. 下单时后端生成唯一 Token，返回给前端；2. 支付时前端携带 Token；3. 后端验证 Token 有效性（Redis 存储，一次有效） | 防止页面重复提交       | 优点：与业务解耦；缺点：需要额外存储 Token             |
| 数据库唯一索引       | 支付记录表中，建立 订单 ID 的唯一索引，重复插入时会触发主键冲突           | 支付结果落地场景       | 优点：数据库层面兜底；缺点：只能作为最后防线，无法提前拦截 |


#### 3. 第三层：支付回调的幂等处理（解决第三方重复通知）
支付完成后，第三方支付平台（如支付宝）可能因网络超时重复推送支付结果回调，需保证回调接口的幂等性。
核心措施：
- **唯一回调 ID 校验**  
第三方回调时会携带唯一的 out_trade_no（订单号）或 trade_no（交易号）；
后端用 trade_no 作为幂等 Key，存入 Redis（设置过期时间），首次处理时标记为「处理中」，处理完成后标记为「已完成」；
重复回调时，若 Redis 中存在该 Key，直接返回成功，不重复处理。

- **最终一致性校验**  
回调处理完成后，异步查询第三方支付平台的订单状态，确认支付结果是否与本地一致；
若不一致，触发补偿机制（如人工对账、自动退款）。

#### 4. 第四层：异步对账与补偿（兜底方案，解决极端异常）
即使前面三层防护，仍可能因系统故障、网络分区导致少量重复支付，需通过对账机制兜底。
核心措施：
- 定时对账任务  
每天凌晨执行对账任务，对比本地订单支付记录和第三方支付平台的交易记录；
找出差异订单（如本地未支付但第三方已扣款、重复扣款）。

- 自动 / 人工补偿  
对重复扣款的订单，触发自动退款流程；
对异常订单，生成对账差异报表，通知运营人员人工处理。
 
- 日志审计  
记录所有支付请求、回调请求的完整日志（包括请求参数、时间戳、处理结果）；
日志需持久化存储，便于事后追溯问题。

---








