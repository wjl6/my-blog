---
title: "002-Milvus.md"
date: 2025-12-30 12:51:29
tags: []
---


## 一、Milvus 基础认知

### 1. 什么是 Milvus？它解决了什么问题？
Milvus 是一个**高性能、分布式向量数据库**，用于存储、索引和检索高维向量数据，主要解决**语义相似度搜索**问题。

**典型场景：**
- RAG（检索增强生成）
- 语义搜索
- 推荐系统
- 多模态检索（图像 / 文本 / 音频）

---

### 2. Milvus 与传统关系型数据库的核心区别？

| 对比项 | MySQL | Milvus |
|------|------|--------|
| 数据类型 | 标量 | 向量 + 标量 |
| 查询方式 | 精确 / 范围 | 相似度搜索 |
| 索引 | B+Tree | ANN |
| 使用场景 | 业务数据 | 语义数据 |

---

### 3. Milvus 支持哪些向量相似度度量？
- L2（欧式距离）
- IP（内积）
- Cosine Similarity

> Cosine 相似度通常通过向量归一化后使用 IP 实现。

| 度量类型         | 英文标识          | 适用向量类型                | 相似性判断       | 典型索引                |
|------------------|-------------------|-----------------------------|------------------|-------------------------|
| 欧氏距离         | L2                | 浮点向量（FLOAT/INT8/BFLOAT16） | 数值越小越相似   | IVF_FLAT、HNSW、DISKANN |
| 内积             | IP                | 浮点 / 稀疏向量             | 数值越大越相似   | 稀疏反转索引、IVF_PQ    |
| 余弦相似度       | COSINE            | 浮点向量                    | 越接近 1 越相似  | HNSW、GPU_IVF_PQ        |
| 汉明距离         | HAMMING           | 二进制向量                  | 数值越小越相似   | BIN_FLAT、BIN_IVF_FLAT  |
| 杰卡德距离       | JACCARD           | 二进制向量                  | 数值越小越相似   | BIN_FLAT、BIN_IVF_FLAT  |
| BM25             | BM25              | 稀疏浮点向量                | 分数越高越相似   | 稀疏反转索引            |
| 塔尼莫托距离     | TANIMOTO          | 二进制向量                  | 数值越小越相似   | BIN_FLAT                |
| 超结构 / 子结构  | SUPERSTRUCTURE/SUBSTRUCTURE | 二进制向量        | 匹配则距离为 0   | BIN_FLAT                |

---

## 二、核心概念（高频）

### 1. Collection、Partition、Segment 的区别？

- **Collection**：类似关系型数据库的表
- **Partition**：逻辑分区，用于业务隔离
- **Segment**：**物理存储单元，由 Milvus 自动管理**

> 查询实际是针对 Segment 执行的。

| 层级       | 核心定义                                                                 | 本质         | 类比（关系型数据库）|
|------------|--------------------------------------------------------------------------|--------------|-----------------------------|
| Collection | Milvus 中最高级别的逻辑数据容器，定义了向量字段、标量字段、相似度度量等元数据 | 逻辑表       | 数据库中的 “表”（Table）|
| Partition  | Collection 下的逻辑子集合，由用户按业务规则（如时间、地域）划分，同一 Collection 内的 Partition 共享 Schema | 逻辑分区     | 表的 “分区”（如按日期分区的订单表） |
| Segment    | Partition 下的物理存储单元，是 Milvus 数据存储和索引的最小单位，由系统自动创建 / 合并 / 删除 | 物理分片     | 数据库的 “数据页 / 文件块”（对用户透明） |

| 对比维度   | Collection                                  | Partition                                  | Segment                                      |
|------------|---------------------------------------------|--------------------------------------------|----------------------------------------------|
| 管理粒度   | 最高级（逻辑表）| 中级别（逻辑分区）| 最低级（物理分片）|
| 管理主体   | 用户手动创建 / 删除                         | 用户手动创建 / 删除                        | Milvus 自动管理                              |
| 数据结构   | 定义 Schema（向量 + 标量字段）| 继承 Collection 的 Schema，无独立 Schema   | 遵循 Collection 的 Schema，物理存储          |
| 索引配置   | 可全局配置，也可按 Partition 配置           | 可单独配置索引（覆盖全局配置）| 索引基于 Segment 构建（用户不可配）|
| 检索范围   | 全表检索（默认）| 指定 Partition 检索（缩小范围）| 检索时扫描匹配的 Segment（透明）|
| 典型操作   | 创建、删除、加载、索引、查询                | 创建、删除、加载、释放、单独查询           | 仅可查看信息，自动合并 / 清理                |

#### Collection 设计原则
1. **同类数据归为一个 Collection**：如 “所有文档的嵌入向量” 放在一个 Collection，避免过多 Collection 增加管理成本；
2. 合理设计 Schema：标量字段仅保留检索 / 过滤必需的（如 ID、时间、标签），避免冗余。

#### Partition 设计原则
1. **按 “检索过滤维度” 分区**：优先选择查询时高频过滤的维度（如时间、地域），避免无意义分区；
2. 分区数量不宜过多：建议单个 Collection 下的 Partition 数不超过 100，过多会增加元数据管理开销；
3. **冷热数据分区隔离**：将近期高频访问的数据放在一个 Partition（加载到内存），冷数据放在另一个 Partition（释放到磁盘）。

#### Segment 优化原则（间接影响）
1. **配置合理的 segment_size**：默认 512MB，可根据数据量调整（如亿级数据设为 1GB），减少小 Segment 数量；
2. **避免频繁小批量插入**：小批量插入会生成大量小 Segment，建议批量插入（如每次插入 1w+ 条）；
3. 定期合并 Segment：通过 Milvus 配置自动合并，或手动触发合并（仅 Milvus 2.x 部分版本支持）。

#### 总结
Collection、Partition、Segment 是 Milvus 从 “逻辑” 到 “物理” 的三层数据组织方式：
- **Collection 定 “结构”**：定义数据的整体规范，是业务操作的入口；
- **Partition 做 “隔离”**：按业务维度拆分数据，提升检索效率和管理灵活性；
- **Segment 管 “存储”**：底层物理分片，决定检索性能的底层逻辑（用户透明但可通过配置优化）。

理解三者的区别，核心是：用户通过 Collection 定义数据结构，通过 Partition 优化检索范围，Milvus 通过 Segment 管理物理存储。


---

### 2. Milvus 的数据模型是怎样的？
- 向量字段（必选）
- 标量字段（可选）
- 支持 Hybrid Search（向量 + 标量过滤）

Milvus 数据模型的设计，完全围绕向量检索的高性能和易用性，核心特点如下：
1.  **混合存储**：支持向量字段与标量字段共存，实现 “向量检索 + 标量过滤” 的一体化查询；
2.  **分层架构**：逻辑层（Collection-Partition）+ 物理层（Segment），兼顾业务灵活性与存储性能；
3.  **用户友好**：类比关系型数据库的表 - 分区模型，降低学习成本；
4.  **高性能优化**：通过 Segment 合并、冷热分离、索引优化等机制，保障大规模向量检索的效率。


---

### 3. Milvus 中的主键有什么特点？

| 属性          | 取值 / 规则                          | 说明                                                                 |
|-------------|--------------------------------------|----------------------------------------------------------------------|
| **必选性&唯一性**     | 强制存在                             | 每个 Collection 必须且只能有 1 个主键，无主键无法创建集合             |
| 数据类型        | 仅支持 INT64 / VARCHAR               | - INT64：适合数值型 ID（如自增、用户 ID），支持 auto_id<br>- VARCHAR：适合字符串标识（如 UUID），需指定 max_length（1-65535） |
| is_primary  | 必须设为 True                        | 显式标记为主键，无此标记字段无法作为主键                             |
| auto_id     | True/False（仅 INT64 支持 True）| - True：Milvus 自动生成唯一 ID，插入时无需传主键<br>- False：需用户手动输入，需自行保证唯一性 |
| 空值约束        | 不允许空值                           | 主键值不可为 NULL，插入时会校验并拒绝空值记录                        |
| Schema 不可变性 | 类型 / 属性创建后不可改              | 主键字段的类型、auto_id 等属性一旦定义，无法通过 ALTER 修改，只能重建集合 |

> 向量索引结构不可变，更新成本极高。

---

## 三、索引与检索（重中之重）

### 1. Milvus 中有哪些向量类型？
| 向量格式       | 核心定位                 | 空间开销 | 检索速度 | 精度   | 典型场景                     | 硬件依赖       |
|----------------|--------------------------|----------|----------|--------|------------------------------|----------------|
| FP32Vector     | 高精度稠密向量基准       | 最大     | 最慢     | 最高   | 科学计算、医疗影像检索       | 无             |
| FP16Vector     | 平衡型稠密向量（主流）| 中等     | 中等     | 中高   | RAG、图像特征检索            | 现代 CPU/GPU   |
| Int8Vector     | 极致压缩稠密向量         | 小       | 快       | 中等   | 实时推荐、边缘设备检索       | 无             |
| BFloat16Vector | AI 友好型 16 位浮点向量  | 中等     | 中快     | 中     | 大模型 Embedding 检索        | AI 芯片        |
| BinaryVector   | 比特级极致压缩向量       | 极小     | 极快     | 最低   | 海量粗筛、边缘设备           | 无             |
| SparseFloatVector | 稀疏数据专用           | 动态     | 快（非零少） | 无损   | TF-IDF 文本检索、用户行为    | 无             |

---

### 2. Milvus 支持哪些向量索引类型？

| 向量类型       | 支持索引                                     | 典型相似度度量       | 核心场景                     |
|----------------|----------------------------------------------|----------------------|------------------------------|
| 稠密浮点向量   | FLAT、IVF_FLAT、IVF_SQ8、IVF_PQ、HNSW、DISKANN、GPU_IVF_FLAT、GPU_IVF_PQ、RHNSW_PQ | L2、COSINE、IP       | 通用语义检索、图像检索       |
| 二进制向量     | BIN_FLAT、BIN_IVF_FLAT、MINHASH_LSH           | HAMMING、JACCARD     | 指纹匹配、文本快速去重       |
| 稀疏浮点向量   | SPARSE_INVERTED_INDEX                        | IP、BM25             | 混合检索（稠密 + 稀疏）、全文语义匹配 |

> IVF -- IVF-Flat 倒排文件索引

#### 1. 稠密浮点向量索引（最常用）
| 索引类型     | 实现类别           | 核心优势                                   | 资源开销                | 召回与速度                | 关键参数                                          |
|--------------|--------------------|--------------------------------------------|-------------------------|---------------------------|---------------------------------------------------|
| **FLAT**         | 暴力检索           | 召回率 100%（无近似误差）| 内存 / 存储：大         | 召回：100%；速度：极慢    | 无（无索引逻辑，直接计算全量距离）|
| **IVF_FLAT**     | 聚类 + 无量化      | 平衡召回与速度，精度接近 FLAT               | 内存 / 存储：中         | 召回：≈98%；速度：中等    | **nlist**（聚类数）、nprobe（查询簇数）|
| IVF_SQ8      | 聚类 + 8 位标量量化 | 存储 / 计算成本低，适配大规模数据           | 内存 / 存储：小（FP32 的 1/4） | 召回：≈90%；速度：快      | nlist、nprobe、量化步长（自动计算）|
| IVF_PQ       | 聚类 + 乘积量化     | 存储开销极低，适合超大规模数据             | 内存 / 存储：极小（FP32 的 1/32~1/64） | 召回：≈90%~95%；速度：极快 | nlist、nprobe、M（子向量数）|
| IVF_RABITQ   | 聚类 + 混合量化     | 量化精度更高，平衡存储与召回               | 内存 / 存储：小         | 召回：≈95%；速度：快      | nlist、nprobe、量化位数（自动适配）|
| **HNSW**         | 分层小世界图       | 检索速度极快，召回率接近 FLAT               | 内存：大；存储：中      | 召回：≈99%；速度：最快    | **M（邻接数）**、ef（查询范围）、**ef_construction（构建范围）** |
| HNSW_SQ      | HNSW + 标量量化    | 降低 HNSW 内存开销，保持高速度             | 内存：中；存储：小      | 召回：≈95%；速度：快      | M、ef、量化步长                                   |
| HNSW_PQ      | HNSW + 乘积量化    | 极致降低 HNSW 内存开销，适配超大规模       | 内存：小；存储：极小    | 召回：≈90%；速度：极快    | M、ef、M_pq（子向量数）|
| HNSW_PRQ     | HNSW + 优化乘积量化 | 量化精度优于 PQ，平衡存储与召回             | 内存：中；存储：小      | 召回：≈93%；速度：快      | M、ef、M_prq（子向量数）|
| SCANN        | 分层聚类 + 量化     | 谷歌优化的高吞吐索引，适配高维向量         | 内存：中；存储：中      | 召回：≈95%；速度：快      | num_leaves（聚类数）、num_leaves_to_search（查询簇数） |
| DISKANN      | 磁盘优化 HNSW      | 支持磁盘存储，降低内存依赖                 | 内存：小；存储：大      | 召回：≈95%；速度：中      | M、ef、磁盘缓存大小                               |
| AISAQ        | 磁盘量化索引       | 磁盘存储 + 量化，适配超大规模离线检索       | 内存：极小；存储：大    | 召回：≈85%；速度：中      | 量化位数、磁盘分块大小                           |
| GPU_CAGRA    | GPU 加速 HNSW      | GPU 硬件加速，吞吐量极高                   | 显存：大；存储：中      | 召回：≈99%；速度：GPU 级最快 | M、ef、GPU 并行数                                 |
| GPU_IVF_FLAT | GPU 加速 IVF       | GPU 加速聚类检索，平衡精度与速度           | 显存：中；存储：中      | 召回：≈98%；速度：GPU 级快 | nlist、nprobe、GPU 核数                           |
| GPU_IVF_PQ   | GPU 加速 IVF+PQ    | GPU 加速量化检索，极致吞吐量               | 显存：小；存储：极小    | 召回：≈90%；速度：GPU 级极快 | nlist、nprobe、M                                   |
| AUTOINDEX    | 自动选择索引       | 自动适配数据规模 / 硬件，无需手动调参       | 动态适配                | 召回与速度：自动平衡      | 无（系统自动选择参数）|

#### 2. 二进制向量索引
| 索引类型     | 实现类别               | 核心优势                                   | 资源开销                      | 召回与速度                      | 关键参数                                          |
|--------------|------------------------|--------------------------------------------|-------------------------------|---------------------------------|---------------------------------------------------|
| AUTOINDEX    | 自动适配索引           | 自动选择最优索引（适配数据 / 硬件），无需手动调参 | 动态适配                      | 召回与速度：自动平衡            | 无（系统自动决策）|
| BIN_FLAT     | 二进制向量暴力检索     | 二进制向量专用，位运算速度快，召回率 100%   | 内存 / 存储：极小（1bit / 维度） | 召回：100%；速度：二进制场景下快 | 无（全量位运算计算汉明距离）|
| BIN_IVF_FLAT | 二进制向量 + 聚类      | 二进制向量专用，聚类缩小检索范围，平衡速度与存储 | 内存 / 存储：极小              | 召回：≈95%；速度：二进制场景下极快 | nlist（聚类数）、nprobe（查询簇数）|

#### 3. 稀疏向量索引
- **SPARSE_INVERTED_INDEX**：基于倒排索引，适配稀疏向量（如 BM25/SPLADE 输出），支持与稠密向量混合检索，适合 RAG 中 **“全文 + 语义” 联合查询**场景。

#### 关键选型决策框架
- **优先选 FLAT**：小数据集（百万级以下）、要求 100% 召回（如学术验证、小规模验证）。
- **优先选 IVF_FLAT**：中大规模（千万级）、追求召回与速度平衡，资源中等。
- 优先选 IVF_SQ8：内存紧张、CPU-only 环境，允许召回轻微下降（如边缘设备）。
- **优先选 HNSW**：高并发低延迟场景（如实时推荐），内存充足，追求最快速度与高召回。
- 优先选 DISKANN：超大规模（亿级 +）、内存有限，允许磁盘 IO 开销（如冷数据检索）。
- 优先选 GPU 索引：高并发场景，有 GPU 资源，需极致查询速度（如电商实时搜索）。
- 二进制向量：优先 BIN_IVF_FLAT；
- 稀疏向量固定用 SPARSE_INVERTED_INDEX。

---

### 3. milvus中稠密向量、二进制向量、稀疏向量分别支持哪几种向量度量？

| 向量类型                | 支持的向量度量类型                                   | 说明                                                                 |
|-------------------------|------------------------------------------------------|----------------------------------------------------------------------|
| 稠密向量（FLOAT/FP16/BF16/INT8） | 1. L2（欧氏距离）<br>2. IP（内积）<br>3. COSINE（余弦距离） | 三种度量均为浮点型向量专用，若向量做 L2 归一化，COSINE 等价于 IP       |
| 二进制向量（BINARY_VECTOR）| 1. HAMMING（汉明距离）<br>2. JACCARD（杰卡德距离）| 两种度量均为二值向量专用，基于位运算计算                             |
| 稀疏向量（SPARSE_FLOAT_VECTOR） | 1. IP（内积）<br>2. BM25（全文检索专用度量）| 仅支持这两种，BM25 适配文本类稀疏特征的相似度计算                     |

| 度量方式       | 含义                | 说明      | 是否考虑向量长度 | 关键适用前提                             |
| ---------- | ----------------- | ------- |----------|------------------------------------|
| **L2**     | 欧氏距离              | 距离越小越相似 |     ✅ 考虑     | 向量长度有实际业务意义（如特征的强度、密度）             |
| **IP**     | Inner Product（内积） | 值越大越相似  |     ✅ 考虑     | 向量已做归一化，或长度代表重要性（如 Embedding 的置信度） |
| **COSINE** | 余弦相似度             | 余弦值越大越相似 |    ❌ 不考虑      | 只关注向量的方向相似性，忽略长度差异  （推荐文本向量）             |

> COSINE 本质 ≈ 归一化后的 IP          
> 归一化：把向量缩放到 “模长 = 1” 的单位向量，消除长度对相似度的影响   
> 如果你的 embedding 已经做了归一化
👉 IP 和 COSINE 效果几乎一致  
> 若用 Cosine，**Milvus 内部会自动归一化后计算 IP，性能无差异**

| 度量方式   | 含义                 | 说明                                                         | 是否考虑向量长度（二进制维度数） | 关键适用前提                                  |
|------------|----------------------|--------------------------------------------------------------|----------------------------------|-----------------------------------------|
| HAMMING    | 汉明距离             | 距离越小越相似（统计两个二进制向量不同比特的数量）| ❌ 不考虑                        | 关注二进制向量的比特位匹配度，如指纹识别、简单特征编码匹配（向量必须等长）   |
| JACCARD    | 杰卡德距离 / 系数    | 系数越大越相似（公式：交集比特数 / 并集比特数）| ❌ 不考虑                        | 关注二进制向量的集合重叠度，如文本关键词存在性匹配、商品标签交集匹配      |
| TANIMOTO   | 谷本系数             | 系数越大越相似（二进制场景下与 Jaccard 公式等价）| ❌ 不考虑                        | 与 Jaccard 适用场景一致，部分框架（如 Milvus）作为独立选项支持 |


---

### 4. IVF 索引中的 nlist 和 nprobe 是什么？

> **IVF（Inverted File，倒排文件）** 是 Milvus 中用于**大规模向量检索**的核心近似最近邻（ANN）索引之一，其核心思想是 “**先聚类分区，再在小范围内精准检索**”，通过牺牲少量精度换取检索速度的大幅提升，适用于百万级以上的海量向量场景。

- **nlist**：聚类中心数量
- **nprobe**：查询时探测的聚类数量

> nprobe 越大，召回率越高，延迟越大。

| 参数  | 阶段       | 作用                                                                 | 取值范围                  | 默认值 | 类比                     |
|-------|------------|----------------------------------------------------------------------|---------------------------|--------|--------------------------|
| nlist | 索引创建   | 用 k-means 将向量划分为 nlist 个簇，每个簇有一个质心，决定分区粒度 | [1, 65536]                | 128    | 图书馆的书架总数，越多越细 |
| nprobe| 查询检索   | 搜索时先找查询向量最近的 nprobe 个簇，只在这些簇内计算精确距离     | [1, nlist]（CPU）；GPU 上限 2048 | 8      | 找书时查的书架数量，越多越全 |

| 参数变化 | 召回率                 | 查询速度               | 构建耗时 | 内存 / 存储 | 适用场景                     |
|----------|------------------------|------------------------|----------|-------------|------------------------------|
| nlist ↑  | 上升（簇更细）| 可提升（单簇向量少）| 增加     | 轻微上升    | 千万 / 亿级数据，追求更高召回 |
| nlist ↓  | 下降（簇更粗）| 轻微下降               | 减少     | 轻微下降    | 中小数据集，快速构建索引     |
| nprobe ↑ | 上升（覆盖更多候选）| 下降（计算量增加）| 无影响   | 无影响      | 高召回场景（如学术验证）|
| nprobe ↓ | 下降（易漏候选）| 上升（计算量减少）| 无影响   | 无影响      | 高并发低延迟场景（如推荐）|
 

---


### 5. flat和ivf_flat有什么区别？

| 特性       | Flat（扁平索引）| IVF-Flat（倒排文件 + 扁平索引）|
|------------|--------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------|
| 核心原理   | 无索引结构，直接存储原始向量，检索时与数据库中所有向量逐一计算距离       | 先通过聚类算法（如 k-means）将向量划分为多个 “桶”，检索时先定位目标向量所在的桶，再在桶内做 Flat 全量检索                                     |
| 检索精度   | 100% 精确（暴力匹配无近似误差）| 近似精确（桶的数量会影响精度，桶越多越接近 Flat）|
| 检索速度   | 极慢，时间复杂度 O (n)（n 为向量总数），随数据量增长急剧下降            | 较快，时间复杂度 O (n/k)（k 为桶的数量），数据量越大优势越明显                                                                               |
| 内存占用   | 仅存储原始向量，内存消耗较低                                             | 除原始向量外，需额外存储聚类中心，内存消耗略高于 Flat                                                                                         |
| 适用场景   | 小规模向量数据集（万级及以下），对精度要求极高的场景                     | 中大规模向量数据集（百万至千万级），需平衡速度与精度的场景                                                                                   |


---

### 6. 一次向量搜索的执行流程？

#### 一、前置准备：索引加载与参数配置
在**执行向量搜索前，必须完成数据写入、索引构建、集合加载三个前置操作**，否则无法进行高效检索：

#### 1. 数据写入与刷盘
- 向量数据 + 标量数据插入 Milvus 后，先写入内存的 WAL（预写日志）；
- 达到 flush_interval 阈值后，内存数据刷盘生成 Segment（物理存储单元）；
- 若开启了 Compaction（合并），小 Segment 会被合并为大 Segment，减少后续检索的扫描开销。

#### 2. 索引构建
- 针对目标向量字段创建索引（如 IVF_FLAT、HNSW），索引数据与 Segment 绑定存储；
- 不同索引的构建逻辑不同：
    - FLAT：无需构建，直接存储原始向量；
    - IVF：用 k-means 聚类生成 nlist 个质心，向量分配到对应簇；
    - HNSW：构建多层图结构，每层保留部分节点的邻居关系。

#### 3. 集合加载到内存
- 执行 collection.load() 命令，将索引数据和热数据 Segment 加载到内存；
- 冷数据 Segment 可留在磁盘，查询时按需加载（仅 DISKANN 等磁盘索引支持）；
- 加载完成后，Milvus 才具备快速检索的条件。

#### 二、核心执行：向量搜索四阶段流程
以最常用的 IVF 索引为例，完整搜索流程如下（HNSW/FLAT 仅粗筛阶段不同）：

#### 阶段 1：请求解析与预处理
1. **接收查询请求**
   客户端传入 查询向量、标量过滤条件（如 category == "技术文档"）、检索参数（如 nprobe）、返回条数 limit。
2. **参数校验**
    - 检查查询向量维度是否与集合 Schema 一致（如 768 维）；
    - 检查 nprobe ≤ nlist（IVF 索引）、ef 合理（HNSW 索引）；
    - 校验用户权限、集合状态（是否已加载）。
3. **向量预处理（可选）**
    - 若相似度度量为 COSINE，自动对查询向量做 L2 归一化（保证向量模长为 1）；
    - 若为二进制向量，转换为比特串格式。

#### 阶段 2：粗筛 - 缩小候选范围（索引核心作用）
粗筛的目标：从百万 / 亿级向量中，快速筛选出与查询向量最相似的一批候选向量，减少后续精确计算的开销。

不同索引的粗筛逻辑差异极大：

| 索引类型   | 粗筛逻辑                                                                 |
|------------|--------------------------------------------------------------------------|
| FLAT（暴力检索） | 无粗筛，直接进入精排阶段（遍历所有向量）|
| IVF_XXX    | 1. 计算查询向量与 nlist 个簇质心的距离；<br>2. 选取距离最近的 nprobe 个簇；<br>3. 将这 nprobe 个簇内的所有向量作为候选集 |
| HNSW       | 1. 从图的顶层开始，贪心搜索找到距离查询向量最近的节点；<br>2. 逐层向下细化搜索范围；<br>3. 在底层图中获取 ef 个候选节点（向量） |
| DISKANN    | 1. 从内存中的 “锚点向量” 出发，找到磁盘中对应的向量块；|

#### 阶段 3：精排 - 精确计算相似度并排序
1. **过滤候选集（可选）**
    - 对粗筛得到的候选向量，应用标量过滤条件（如时间范围、分类标签）；
    - 过滤掉不符合条件的向量，缩小候选集规模。
2. **精确计算相似度**
   计算查询向量与候选集中每个向量的精确距离（按集合定义的度量方式）：
    - 浮点向量：L2 距离、IP 内积、COSINE 相似度；
    - 二进制向量：HAMMING 距离、JACCARD 相似度。
3. **Top-K 排序**
    - 按相似度分数排序（L2/HAMMING 越小越优，IP/COSINE 越大越优）；
    - 取前 limit 个向量，作为初步结果集。

#### 阶段 4：后处理与结果返回
1. **结果补充**
    - 从结果集中提取向量对应的标量字段（如文档 ID、标题、时间），按用户请求的 output_fields 组装；
    - 若开启了一致性校验，过滤掉已被软删除但未清理的向量。
2. **结果封装与返回**
    - 将最终结果封装为统一格式（包含向量 ID、相似度分数、标量字段值）；
    - 把结果返回给客户端；
    - 记录检索日志（耗时、候选集大小、召回率等），用于后续性能优化。

---

## 四、Milvus 架构（必考）

### 1. Milvus 的整体架构是怎样的？

| 层级       | 核心职责                                                         | 关键组件                                 |
|------------|------------------------------------------------------------------|------------------------------------------|
| 接入层     | 接收客户端请求、路由分发、负载均衡、权限校验、请求限流           | Proxy                                    |
| 计算层     | 向量索引构建、向量检索计算、标量过滤、数据插入 / 删除 / 合并     | Query Node、Data Node、Index Node        |
| 协调层     | 集群元数据管理、节点负载调度、数据分片分配、故障检测与恢复       | Root Coordinator、Index Coordinator、Data Coordinator、Query Coordinator |
| 存储层     | 元数据持久化、向量数据 / 索引数据持久化、日志存储                | etcd、MinIO/S3（对象存储）、Local Disk（可选） |

> Milvus 是计算与存储分离架构。

---

### 2. Milvus 如何保证高可用？

Milvus 的高可用是全链路、分层级的保障体系，核心是：

- **存储层**：etcd 多副本 + 对象存储多副本，确保数据不丢失；
- **计算层**：无状态节点 + 多实例部署，确保业务不中断；
- **协调层**：组件冗余 + 故障自动转移，确保集群管控不失效；
- **接入层**：负载均衡 + 请求容错，确保客户端访问无感知。

---

## 五、Milvus 与 RAG（超高频）

### 1. Milvus 在 RAG 架构中的作用？
Milvus 在 RAG 架构中的核心价值是 “提供**高效、精准、可扩展的向量检索能力**”，是 RAG 系统从 “实验室原型” 走向 “生产级应用” 的关键组件：
- **对开发侧**：降低向量存储与检索的开发成本，支持与主流 RAG 框架无缝集成；
- **对性能侧**：支撑大规模知识库的低延迟检索，满足高并发场景需求；
- **对效果侧**：通过精准的上下文召回，大幅提升大模型回答的准确性，减少幻觉。

### 2. Milvus 与 pgvector / Elasticsearch 如何选择？
| 场景 | 推荐方案 |
|------|----------|
| 百万级以下 | pgvector |
| 关键词 + 语义 | Elasticsearch |
| 千万 / 亿级向量 | Milvus |

## 六、性能与调优（中高级）
### 1. 如何提升 Milvus 查询性能？
- 合理选择索引类型
- 控制 nprobe
- 使用 Partition
- 启用 Hybrid Filter
- 控制 Segment 数量

### 2. Milvus 查询慢的排查思路？
- 是否命中索引
- nprobe 是否过大
- Segment 是否过多
- QueryNode 是否瓶颈
- IO / 网络是否异常

## 七、生产实践与常见坑
### 1. Milvus 是否支持事务？
- ❌ 不支持事务
- ✔ 最终一致性

### 2. Milvus 适合存业务主数据吗？
不适合，仅用于向量与轻量元数据存储。

### 3. Milvus 如何处理删除？
- 支持 delete
- 实际为逻辑删除
- 通过 compaction 才会释放物理空间