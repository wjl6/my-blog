---
title: "002-Milvus.md"
date: 2025-12-30 12:51:29
tags: []
---


## 一、Milvus 基础认知

### 1. 什么是 Milvus？它解决了什么问题？
Milvus 是一个**高性能、分布式向量数据库**，用于存储、索引和检索高维向量数据，主要解决**语义相似度搜索**问题。

**典型场景：**
- RAG（检索增强生成）
- 语义搜索
- 推荐系统
- 多模态检索（图像 / 文本 / 音频）

---

### 2. Milvus 与传统关系型数据库的核心区别？

| 对比项 | MySQL | Milvus |
|------|------|--------|
| 数据类型 | 标量 | 向量 + 标量 |
| 查询方式 | 精确 / 范围 | 相似度搜索 |
| 索引 | B+Tree | ANN |
| 使用场景 | 业务数据 | 语义数据 |

---

### 3. Milvus 支持哪些向量相似度度量？
- L2（欧式距离）
- IP（内积）
- Cosine Similarity

> Cosine 相似度通常通过向量归一化后使用 IP 实现。

| 度量类型         | 英文标识          | 适用向量类型                | 相似性判断       | 典型索引                |
|------------------|-------------------|-----------------------------|------------------|-------------------------|
| 欧氏距离         | L2                | 浮点向量（FLOAT/INT8/BFLOAT16） | 数值越小越相似   | IVF_FLAT、HNSW、DISKANN |
| 内积             | IP                | 浮点 / 稀疏向量             | 数值越大越相似   | 稀疏反转索引、IVF_PQ    |
| 余弦相似度       | COSINE            | 浮点向量                    | 越接近 1 越相似  | HNSW、GPU_IVF_PQ        |
| 汉明距离         | HAMMING           | 二进制向量                  | 数值越小越相似   | BIN_FLAT、BIN_IVF_FLAT  |
| 杰卡德距离       | JACCARD           | 二进制向量                  | 数值越小越相似   | BIN_FLAT、BIN_IVF_FLAT  |
| BM25             | BM25              | 稀疏浮点向量                | 分数越高越相似   | 稀疏反转索引            |
| 塔尼莫托距离     | TANIMOTO          | 二进制向量                  | 数值越小越相似   | BIN_FLAT                |
| 超结构 / 子结构  | SUPERSTRUCTURE/SUBSTRUCTURE | 二进制向量        | 匹配则距离为 0   | BIN_FLAT                |

---

## 二、核心概念（高频）

### 1. Collection、Partition、Segment 的区别？

- **Collection**：类似关系型数据库的表
- **Partition**：逻辑分区，用于业务隔离
- **Segment**：**物理存储单元，由 Milvus 自动管理**

> 查询实际是针对 Segment 执行的。

| 层级       | 核心定义                                                                 | 本质         | 类比（关系型数据库）|
|------------|--------------------------------------------------------------------------|--------------|-----------------------------|
| Collection | Milvus 中最高级别的逻辑数据容器，定义了向量字段、标量字段、相似度度量等元数据 | 逻辑表       | 数据库中的 “表”（Table）|
| Partition  | Collection 下的逻辑子集合，由用户按业务规则（如时间、地域）划分，同一 Collection 内的 Partition 共享 Schema | 逻辑分区     | 表的 “分区”（如按日期分区的订单表） |
| Segment    | Partition 下的物理存储单元，是 Milvus 数据存储和索引的最小单位，由系统自动创建 / 合并 / 删除 | 物理分片     | 数据库的 “数据页 / 文件块”（对用户透明） |

| 对比维度   | Collection                                  | Partition                                  | Segment                                      |
|------------|---------------------------------------------|--------------------------------------------|----------------------------------------------|
| 管理粒度   | 最高级（逻辑表）| 中级别（逻辑分区）| 最低级（物理分片）|
| 管理主体   | 用户手动创建 / 删除                         | 用户手动创建 / 删除                        | Milvus 自动管理                              |
| 数据结构   | 定义 Schema（向量 + 标量字段）| 继承 Collection 的 Schema，无独立 Schema   | 遵循 Collection 的 Schema，物理存储          |
| 索引配置   | 可全局配置，也可按 Partition 配置           | 可单独配置索引（覆盖全局配置）| 索引基于 Segment 构建（用户不可配）|
| 检索范围   | 全表检索（默认）| 指定 Partition 检索（缩小范围）| 检索时扫描匹配的 Segment（透明）|
| 典型操作   | 创建、删除、加载、索引、查询                | 创建、删除、加载、释放、单独查询           | 仅可查看信息，自动合并 / 清理                |

#### Collection 设计原则
1. **同类数据归为一个 Collection**：如 “所有文档的嵌入向量” 放在一个 Collection，避免过多 Collection 增加管理成本；
2. 合理设计 Schema：标量字段仅保留检索 / 过滤必需的（如 ID、时间、标签），避免冗余。

#### Partition 设计原则
1. **按 “检索过滤维度” 分区**：优先选择查询时高频过滤的维度（如时间、地域），避免无意义分区；
2. 分区数量不宜过多：建议单个 Collection 下的 Partition 数不超过 100，过多会增加元数据管理开销；
3. **冷热数据分区隔离**：将近期高频访问的数据放在一个 Partition（加载到内存），冷数据放在另一个 Partition（释放到磁盘）。

#### Segment 优化原则（间接影响）
1. **配置合理的 segment_size**：默认 512MB，可根据数据量调整（如亿级数据设为 1GB），减少小 Segment 数量；
2. **避免频繁小批量插入**：小批量插入会生成大量小 Segment，建议批量插入（如每次插入 1w+ 条）；
3. 定期合并 Segment：通过 Milvus 配置自动合并，或手动触发合并（仅 Milvus 2.x 部分版本支持）。

#### 总结
Collection、Partition、Segment 是 Milvus 从 “逻辑” 到 “物理” 的三层数据组织方式：
- **Collection 定 “结构”**：定义数据的整体规范，是业务操作的入口；
- **Partition 做 “隔离”**：按业务维度拆分数据，提升检索效率和管理灵活性；
- **Segment 管 “存储”**：底层物理分片，决定检索性能的底层逻辑（用户透明但可通过配置优化）。

理解三者的区别，核心是：用户通过 Collection 定义数据结构，通过 Partition 优化检索范围，Milvus 通过 Segment 管理物理存储。


---

### 2. Milvus 的数据模型是怎样的？
- 向量字段（必选）
- 标量字段（可选）
- 支持 Hybrid Search（向量 + 标量过滤）

Milvus 数据模型的设计，完全围绕向量检索的高性能和易用性，核心特点如下：
1.  **混合存储**：支持向量字段与标量字段共存，实现 “向量检索 + 标量过滤” 的一体化查询；
2.  **分层架构**：逻辑层（Collection-Partition）+ 物理层（Segment），兼顾业务灵活性与存储性能；
3.  **用户友好**：类比关系型数据库的表 - 分区模型，降低学习成本；
4.  **高性能优化**：通过 Segment 合并、冷热分离、索引优化等机制，保障大规模向量检索的效率。


---

### 3. Milvus 中的主键有什么特点？

| 属性          | 取值 / 规则                          | 说明                                                                 |
|-------------|--------------------------------------|----------------------------------------------------------------------|
| **必选性&唯一性**     | 强制存在                             | 每个 Collection 必须且只能有 1 个主键，无主键无法创建集合             |
| 数据类型        | 仅支持 INT64 / VARCHAR               | - INT64：适合数值型 ID（如自增、用户 ID），支持 auto_id<br>- VARCHAR：适合字符串标识（如 UUID），需指定 max_length（1-65535） |
| is_primary  | 必须设为 True                        | 显式标记为主键，无此标记字段无法作为主键                             |
| auto_id     | True/False（仅 INT64 支持 True）| - True：Milvus 自动生成唯一 ID，插入时无需传主键<br>- False：需用户手动输入，需自行保证唯一性 |
| 空值约束        | 不允许空值                           | 主键值不可为 NULL，插入时会校验并拒绝空值记录                        |
| Schema 不可变性 | 类型 / 属性创建后不可改              | 主键字段的类型、auto_id 等属性一旦定义，无法通过 ALTER 修改，只能重建集合 |

> 向量索引结构不可变，更新成本极高。

---

## 三、索引与检索（重中之重）

### 7. Milvus 支持哪些向量索引类型？

| 向量类型       | 支持索引                                     | 典型相似度度量       | 核心场景                     |
|----------------|----------------------------------------------|----------------------|------------------------------|
| 稠密浮点向量   | FLAT、IVF_FLAT、IVF_SQ8、IVF_PQ、HNSW、DISKANN、GPU_IVF_FLAT、GPU_IVF_PQ、RHNSW_PQ | L2、COSINE、IP       | 通用语义检索、图像检索       |
| 二进制向量     | BIN_FLAT、BIN_IVF_FLAT、MINHASH_LSH           | HAMMING、JACCARD     | 指纹匹配、文本快速去重       |
| 稀疏浮点向量   | SPARSE_INVERTED_INDEX                        | IP、BM25             | 混合检索（稠密 + 稀疏）、全文语义匹配 |

#### 1. 稠密浮点向量索引（最常用）
| 索引类型          | 实现类别               | 核心优势                                   | 资源开销                     | 召回与速度                   | 关键参数                                   |
|-------------------|------------------------|--------------------------------------------|------------------------------|------------------------------|--------------------------------------------|
| FLAT              | 暴力检索               | 100% 召回，无需参数调优                    | 内存高（全量向量）| 速度最慢，召回 100% | 无额外参数                                 |
| IVF_FLAT          | 量化（聚类）| 召回高、速度快，平衡度好                    | 中（聚类 + 原始向量）| 速度较快，召回≈95%+ | nlist（聚类数）、nprobe（查询聚类数）|
| IVF_SQ8           | 量化（聚类 + 标量量化） | 内存占用降低 75%                            | 低（聚类 + 8bit 量化）| 速度快，召回轻微下降 | nlist、nprobe                              |
| IVF_PQ            | 量化（聚类 + 乘积量化） | 内存 / 磁盘占用极低                         | 极低（聚类 + PQ 编码）| 速度极快，召回明显下降 | nlist、nprobe、m（子向量数）、nbits（编码位数） |
| HNSW              | 图结构                 | 速度与召回双优，综合性能最佳                | 内存高（图结构 + 向量）| 速度最快，召回≈98%+ | M（邻居数）、efConstruction（构建时搜索范围）、ef（查询时搜索范围） |
| DISKANN           | 磁盘优化               | 支持 TB 级数据，内存占用低                 | 内存低、磁盘 IO 中 | 速度中，召回中 | index_bs（块大小）、search_bs（查询块数）|
| GPU_IVF_FLAT/GPU_IVF_PQ | GPU 加速量化 | 高并发、低延迟，适合大规模高 QPS 场景 | GPU 显存中 / 低 | 比 CPU 版快 5–10 倍 | 同 CPU 版，新增 gpu_device_id |
| RHNSW_PQ          | 图 + 量化混合          | 内存友好，速度快，平衡内存与性能            | 中（图 + PQ 编码）| 速度快，召回中等 | M、ef、m、nbits                            |

#### 2. 二进制向量索引
| 索引类型    | 实现类别   | 优势                     | 适用场景                     |
|-------------|------------|--------------------------|------------------------------|
| BIN_FLAT    | 暴力检索   | 100% 召回                | 小批量二进制向量匹配         |
| BIN_IVF_FLAT| 量化聚类   | 速度提升，召回高          | 大规模二进制向量检索         |
| MINHASH_LSH | 哈希       | 快速去重、近似匹配        | 大规模文本 / 图像去重        |

#### 3. 稀疏向量索引
- **SPARSE_INVERTED_INDEX**：基于倒排索引，适配稀疏向量（如 BM25/SPLADE 输出），支持与稠密向量混合检索，适合 RAG 中 **“全文 + 语义” 联合查询**场景。

#### 关键选型决策框架
- **优先选 FLAT**：小数据集（百万级以下）、要求 100% 召回（如学术验证、小规模验证）。
- 优先选 IVF_FLAT：中大规模（千万级）、追求召回与速度平衡，资源中等。
- 优先选 IVF_SQ8：内存紧张、CPU-only 环境，允许召回轻微下降（如边缘设备）。
- 优先选 HNSW：高并发低延迟场景（如实时推荐），内存充足，追求最快速度与高召回。
- 优先选 DISKANN：超大规模（亿级 +）、内存有限，允许磁盘 IO 开销（如冷数据检索）。
- 优先选 GPU 索引：高并发场景，有 GPU 资源，需极致查询速度（如电商实时搜索）。
- **二进制向量**：优先 BIN_IVF_FLAT；
- **稀疏向量固定用** SPARSE_INVERTED_INDEX。

---

### 8. IVF 索引中的 nlist 和 nprobe 是什么？

> **IVF（Inverted File，倒排文件）** 是 Milvus 中用于**大规模向量检索**的核心近似最近邻（ANN）索引之一，其核心思想是 “**先聚类分区，再在小范围内精准检索**”，通过牺牲少量精度换取检索速度的大幅提升，适用于百万级以上的海量向量场景。

- **nlist**：聚类中心数量
- **nprobe**：查询时探测的聚类数量

> nprobe 越大，召回率越高，延迟越大。

| 参数  | 阶段       | 作用                                                                 | 取值范围                  | 默认值 | 类比                     |
|-------|------------|----------------------------------------------------------------------|---------------------------|--------|--------------------------|
| nlist | 索引创建   | 用 k-means 将向量划分为 nlist 个簇，每个簇有一个质心，决定分区粒度 | [1, 65536]                | 128    | 图书馆的书架总数，越多越细 |
| nprobe| 查询检索   | 搜索时先找查询向量最近的 nprobe 个簇，只在这些簇内计算精确距离     | [1, nlist]（CPU）；GPU 上限 2048 | 8      | 找书时查的书架数量，越多越全 |

| 参数变化 | 召回率                 | 查询速度               | 构建耗时 | 内存 / 存储 | 适用场景                     |
|----------|------------------------|------------------------|----------|-------------|------------------------------|
| nlist ↑  | 上升（簇更细）| 可提升（单簇向量少）| 增加     | 轻微上升    | 千万 / 亿级数据，追求更高召回 |
| nlist ↓  | 下降（簇更粗）| 轻微下降               | 减少     | 轻微下降    | 中小数据集，快速构建索引     |
| nprobe ↑ | 上升（覆盖更多候选）| 下降（计算量增加）| 无影响   | 无影响      | 高召回场景（如学术验证）|
| nprobe ↓ | 下降（易漏候选）| 上升（计算量减少）| 无影响   | 无影响      | 高并发低延迟场景（如推荐）|
 

```python
from pymilvus import Collection, CollectionSchema, FieldSchema, DataType, IndexType, MetricType

# 1. 定义集合 Schema（假设向量维度为 768）
id_field = FieldSchema(
    name="id",
    dtype=DataType.INT64,
    is_primary=True,
    auto_id=False
)
vec_field = FieldSchema(
    name="embedding",
    dtype=DataType.FLOAT_VECTOR,
    dim=768
)
schema = CollectionSchema(fields=[id_field, vec_field], description="IVF 索引测试集合")

# 2. 创建集合
collection = Collection(name="vec_collection", schema=schema)

# 3. 插入测试向量（假设已有向量数据 vectors 和对应的 ids）
# collection.insert([ids, vectors])

# 4. 创建 IVF_FLAT 索引
index_params = {
    "metric_type": "L2",  # 距离计算方式：L2 欧氏距离，可选 COSINE（余弦相似度）
    "index_type": "IVF_FLAT",
    "params": {"nlist": 1000}  # 聚类簇数量设为 1000
}
collection.create_index(field_name="embedding", index_params=index_params)

# 5. 加载集合到内存（检索前必须加载）
collection.load()

# 6. 执行检索（设置 nprobe=20）
search_params = {
    "metric_type": "L2",
    "params": {"nprobe": 20}
}
query_vector = [[0.1, 0.2, ..., 0.768]]  # 测试查询向量（维度 768）
results = collection.search(
    data=query_vector,
    anns_field="embedding",
    param=search_params,
    limit=10,  # 返回 Top-10 结果
    expr=None
)

# 7. 打印结果
for hit in results[0]:
    print(f"向量 ID: {hit.id}, 距离: {hit.distance}")

```


---

### 9. 一次向量搜索的执行流程？

#### 一、前置准备：索引加载与参数配置
在**执行向量搜索前，必须完成数据写入、索引构建、集合加载三个前置操作**，否则无法进行高效检索：

#### 1. 数据写入与刷盘
- 向量数据 + 标量数据插入 Milvus 后，先写入内存的 WAL（预写日志）；
- 达到 flush_interval 阈值后，内存数据刷盘生成 Segment（物理存储单元）；
- 若开启了 Compaction（合并），小 Segment 会被合并为大 Segment，减少后续检索的扫描开销。

#### 2. 索引构建
- 针对目标向量字段创建索引（如 IVF_FLAT、HNSW），索引数据与 Segment 绑定存储；
- 不同索引的构建逻辑不同：
    - FLAT：无需构建，直接存储原始向量；
    - IVF：用 k-means 聚类生成 nlist 个质心，向量分配到对应簇；
    - HNSW：构建多层图结构，每层保留部分节点的邻居关系。

#### 3. 集合加载到内存
- 执行 collection.load() 命令，将索引数据和热数据 Segment 加载到内存；
- 冷数据 Segment 可留在磁盘，查询时按需加载（仅 DISKANN 等磁盘索引支持）；
- 加载完成后，Milvus 才具备快速检索的条件。

#### 二、核心执行：向量搜索四阶段流程
以最常用的 IVF 索引为例，完整搜索流程如下（HNSW/FLAT 仅粗筛阶段不同）：

#### 阶段 1：请求解析与预处理
1. **接收查询请求**
   客户端传入 查询向量、标量过滤条件（如 category == "技术文档"）、检索参数（如 nprobe）、返回条数 limit。
2. **参数校验**
    - 检查查询向量维度是否与集合 Schema 一致（如 768 维）；
    - 检查 nprobe ≤ nlist（IVF 索引）、ef 合理（HNSW 索引）；
    - 校验用户权限、集合状态（是否已加载）。
3. **向量预处理（可选）**
    - 若相似度度量为 COSINE，自动对查询向量做 L2 归一化（保证向量模长为 1）；
    - 若为二进制向量，转换为比特串格式。

#### 阶段 2：粗筛 - 缩小候选范围（索引核心作用）
粗筛的目标：从百万 / 亿级向量中，快速筛选出与查询向量最相似的一批候选向量，减少后续精确计算的开销。

不同索引的粗筛逻辑差异极大：

| 索引类型   | 粗筛逻辑                                                                 |
|------------|--------------------------------------------------------------------------|
| FLAT（暴力检索） | 无粗筛，直接进入精排阶段（遍历所有向量）|
| IVF_XXX    | 1. 计算查询向量与 nlist 个簇质心的距离；<br>2. 选取距离最近的 nprobe 个簇；<br>3. 将这 nprobe 个簇内的所有向量作为候选集 |
| HNSW       | 1. 从图的顶层开始，贪心搜索找到距离查询向量最近的节点；<br>2. 逐层向下细化搜索范围；<br>3. 在底层图中获取 ef 个候选节点（向量） |
| DISKANN    | 1. 从内存中的 “锚点向量” 出发，找到磁盘中对应的向量块；|

#### 阶段 3：精排 - 精确计算相似度并排序
1. **过滤候选集（可选）**
    - 对粗筛得到的候选向量，应用标量过滤条件（如时间范围、分类标签）；
    - 过滤掉不符合条件的向量，缩小候选集规模。
2. **精确计算相似度**
   计算查询向量与候选集中每个向量的精确距离（按集合定义的度量方式）：
    - 浮点向量：L2 距离、IP 内积、COSINE 相似度；
    - 二进制向量：HAMMING 距离、JACCARD 相似度。
3. **Top-K 排序**
    - 按相似度分数排序（L2/HAMMING 越小越优，IP/COSINE 越大越优）；
    - 取前 limit 个向量，作为初步结果集。

#### 阶段 4：后处理与结果返回
1. **结果补充**
    - 从结果集中提取向量对应的标量字段（如文档 ID、标题、时间），按用户请求的 output_fields 组装；
    - 若开启了一致性校验，过滤掉已被软删除但未清理的向量。
2. **结果封装与返回**
    - 将最终结果封装为统一格式（包含向量 ID、相似度分数、标量字段值）；
    - 把结果返回给客户端；
    - 记录检索日志（耗时、候选集大小、召回率等），用于后续性能优化。

---

## 四、Milvus 架构（必考）

### 1. Milvus 的整体架构是怎样的？

| 层级       | 核心职责                                                         | 关键组件                                 |
|------------|------------------------------------------------------------------|------------------------------------------|
| 接入层     | 接收客户端请求、路由分发、负载均衡、权限校验、请求限流           | Proxy                                    |
| 计算层     | 向量索引构建、向量检索计算、标量过滤、数据插入 / 删除 / 合并     | Query Node、Data Node、Index Node        |
| 协调层     | 集群元数据管理、节点负载调度、数据分片分配、故障检测与恢复       | Root Coordinator、Index Coordinator、Data Coordinator、Query Coordinator |
| 存储层     | 元数据持久化、向量数据 / 索引数据持久化、日志存储                | etcd、MinIO/S3（对象存储）、Local Disk（可选） |

> Milvus 是计算与存储分离架构。

---

### 2. Milvus 如何保证高可用？

Milvus 的高可用是全链路、分层级的保障体系，核心是：

- **存储层**：etcd 多副本 + 对象存储多副本，确保数据不丢失；
- **计算层**：无状态节点 + 多实例部署，确保业务不中断；
- **协调层**：组件冗余 + 故障自动转移，确保集群管控不失效；
- **接入层**：负载均衡 + 请求容错，确保客户端访问无感知。

---

## 五、Milvus 与 RAG（超高频）

### 1. Milvus 在 RAG 架构中的作用？
Milvus 在 RAG 架构中的核心价值是 “提供**高效、精准、可扩展的向量检索能力**”，是 RAG 系统从 “实验室原型” 走向 “生产级应用” 的关键组件：
- **对开发侧**：降低向量存储与检索的开发成本，支持与主流 RAG 框架无缝集成；
- **对性能侧**：支撑大规模知识库的低延迟检索，满足高并发场景需求；
- **对效果侧**：通过精准的上下文召回，大幅提升大模型回答的准确性，减少幻觉。

### 2. Milvus 与 pgvector / Elasticsearch 如何选择？
| 场景 | 推荐方案 |
|------|----------|
| 百万级以下 | pgvector |
| 关键词 + 语义 | Elasticsearch |
| 千万 / 亿级向量 | Milvus |

## 六、性能与调优（中高级）
### 1. 如何提升 Milvus 查询性能？
- 合理选择索引类型
- 控制 nprobe
- 使用 Partition
- 启用 Hybrid Filter
- 控制 Segment 数量

### 2. Milvus 查询慢的排查思路？
- 是否命中索引
- nprobe 是否过大
- Segment 是否过多
- QueryNode 是否瓶颈
- IO / 网络是否异常

## 七、生产实践与常见坑
### 1. Milvus 是否支持事务？
- ❌ 不支持事务
- ✔ 最终一致性

### 2. Milvus 适合存业务主数据吗？
不适合，仅用于向量与轻量元数据存储。

### 3. Milvus 如何处理删除？
- 支持 delete
- 实际为逻辑删除
- 通过 compaction 才会释放物理空间