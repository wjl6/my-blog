---
title: "001-vue.md"
date: 2026-01-08 15:03:06
tags: []
---

## 1. Vue2 和 Vue3 的区别
Vue3 是在保持 Vue2 使用体验的前提下，**重写了响应式系统和底层架构**，引入 Composition API，**在性能、可维护性和 TypeScript 支持上都有显著提升**。

### 响应式原理不同（必考）

| 对比维度         | Vue2（Object.defineProperty）| Vue3（Proxy）|
|------------------|-----------------------------------------------------------|-----------------------------------------------------------|
| 核心实现         | 数据劫持，重写单个属性的 get/set                          | 对象代理，拦截整个对象的所有操作                          |
| 初始化方式       | 递归遍历所有已有属性，一次性完成劫持                      | 惰性递归，仅访问深层属性时才创建代理                      |
| 支持新增属性     | ❌ 不支持，需使用 Vue.set()                               | ✅ 支持，直接赋值即可触发更新                              |
| 支持删除属性     | ❌ 不支持，需使用 Vue.delete()                            | ✅ 支持，直接 delete 即可触发更新                          |
| 数组支持         | 仅支持 7 种变异方法，不支持索引 / 长度修改                | ✅ 支持所有数组操作（索引、长度、变异方法）|
| 嵌套对象性能     | 初始化递归耗时久，内存开销大                              | 惰性递归，初始化性能高，内存开销小                        |
| 集合类型支持     | ❌ 不支持 Map/Set 等                                       | ✅ 原生支持 Map/Set/WeakMap 等                            |
| 操作规范性       | 直接操作目标对象，无统一返回值                            | 配合 Reflect，操作更规范，返回合理结果                    |
| 兼容性           | 支持 IE9+（兼容旧浏览器）| 支持 ES6+ 浏览器，不兼容 IE（无 Proxy 支持）|

### API 设计：Options API vs Composition API（重点）
Vue2（Options API）
```js
data() {}
methods() {}
computed() {}
watch() {}
```
问题：
- 逻辑分散
- 组件一复杂就“横向拆散”

Vue3（Composition API）
```js
setup() {
  const count = ref(0)
  function add() {}
  return { count, add }
}
```
优势：
- 逻辑按「功能」组织
- 代码可复用（Hooks）
- 对复杂业务更友好

> Composition API 解决的是复杂组件逻辑难以维护的问题，而不是为了替代 Options API。

### 性能提升（Vue3 明显更强）
更快的虚拟 DOM diff
- 编译阶段引入 Patch Flag

Tree Shaking
- 没用到的功能不会打包

更小的包体
- Vue3 runtime 更轻
> Vue3 把一部分运行时工作前移到编译阶段，因此整体渲染性能更好。

### TypeScript 支持（Vue3 完胜）

|       | Vue2               | Vue3 |
| ----- | ------------------ | ---- |
| TS 支持 | 依赖 class-component | 原生支持 |
| 类型推导  | 弱                  | 非常强  |
> Vue3 是在设计阶段就围绕 TypeScript 来做的，Composition API 的类型推导非常自然。

### 新特性 & 语法变化（简要点）

- Fragment：组件可以多个根节点
- Teleport：内容渲染到指定 DOM（如 Modal）
- Suspense：异步组件更优雅
- v-model 改造（支持多个）
- 生命周期命名变化：
  - beforeDestroy → beforeUnmount

---

## 2. Vue 的生命周期？
Vue 生命周期描述的是一个**组件从创建、挂载、更新到销毁的整个过程**，在不同阶段提供了对应的钩子函数，方便我们介入业务逻辑。

- 创建阶段：组件实例创建、初始化，尚未挂载到 DOM（无真实 DOM 操作）；
- **挂载阶段**：组件实例与 DOM 绑定，渲染真实 DOM 到页面（首次渲染，可进行 DOM 操作）；
- 更新阶段：组件响应式数据变化，触发虚拟 DOM 对比与真实 DOM 更新（多次执行）；
- 卸载阶段：组件实例从 DOM 中移除，清理资源（避免内存泄漏）。


### 创建阶段（Creation）

beforeCreate
- data、methods、computed 都还没初始化
- 几乎不用
>👉 典型场景：极少，用来做最早期的插件级逻辑

**created** ⭐（高频）
- data、methods 已初始化
- DOM 还未生成
- 可以：
  - 发起接口请求
  - 初始化数据
- ❌ 不能操作 DOM
> created 适合做数据初始化，不适合做 DOM 操作。

### 挂载阶段（Mounting）

beforeMount
- 模板已编译
- DOM 还没真正挂载
- 用得不多

**mounted** ⭐⭐⭐（重点）
- 真实 DOM 已挂载
- 可以安全操作 DOM
- 可以：
  - 初始化第三方库（ECharts、Map）
  - 获取 DOM 尺寸
> 需要操作 DOM 或使用第三方 UI 库，一般放在 mounted 中。

### 更新阶段（Updating）

beforeUpdate
- data 已变化
- DOM 还没更新
>👉 可以在这里拿到“更新前的 DOM 状态”

updated
- DOM 已完成更新
- ⚠️ 注意：
  - 不要在 updated 里再修改数据
  - 容易造成死循环

### 销毁阶段（Destruction）
beforeDestroy
- 实例还可用
- 清理工作最佳时机
- 常见操作：
  - 清除定时器
  - 解绑事件
  - 取消订阅

destroyed
- 实例完全销毁
- 基本用不到

### Vue3 生命周期变化
| Vue2          | Vue3           |
| ------------- |----------------|
| beforeCreate  | setup()  顶层    |
| created       | setup()  顶层    |
| beforeMount   | onBeforeMount  |
| mounted       | onMounted      |
| beforeUpdate  | onBeforeUpdate |
| updated       | onUpdated      |
| beforeDestroy | onBeforeUnmount |
| destroyed     | onUnmounted    |


---

## 3. Vue 的核心特性有哪些？

#### 双向数据绑定
响应式数据绑定是 Vue 的核心灵魂，Vue 会对组件 data、ref 等声明的数据进行「响应式包装」，当数据发生变化时，与之绑定的 DOM 元素会自动更新（「数据驱动视图」），无需手动操作 DOM，实现了「数据与视图的双向同步（单向数据流下的自动同步）」。

- Vue 2：基于 Object.defineProperty() 劫持对象的属性访问器（getter/setter），当数据被读取时收集依赖，数据被修改时触发依赖更新，进而更新 DOM；
- Vue 3：基于 ES6 的 Proxy 代理整个对象，相比 Object.defineProperty() 支持数组、新增属性的响应式，性能更优、兼容性更强（不支持 IE 浏览器）。

#### 组件化
- Vue 支持组件化开发，将整个页面拆分为多个独立的、可复用的「组件（Component）」，每个组件负责一个特定的功能模块（如按钮、输入框、列表、弹窗），组件可以嵌套、组合，最终拼接成完整的页面。
- Vue 组件具有「高内聚、低耦合」的特点，每个组件拥有独立的模板、脚本和样式，互不干扰。

#### 指令系统
Vue 提供了一套内置的指令系统（以 v- 开头的特殊属性），用于在模板中直接实现常见的 DOM 操作逻辑（如条件渲染、列表循环、数据绑定、事件绑定），指令是声明式编程的具体体现，无需手动编写 JavaScript 代码即可完成复杂功能。

| 指令                  | 核心功能                                     | 实战示例                                          |
|-----------------------|----------------------------------------------|---------------------------------------------------|
| v-text                | 绑定元素文本内容（替代 {{ }}）| <p v-text="message"></p>                           |
| v-html                | 绑定元素 HTML 内容（存在 XSS 风险）| <div v-html="htmlContent"></div>                   |
| v-bind                | 绑定元素属性（简写为 :）| <img :src="imgUrl" :alt="imgName">                 |
| v-on                  | 绑定事件（简写为 @）| <button @click="handleClick">点击</button>         |
| v-if/v-else-if/v-else | 条件渲染（销毁 / 创建 DOM 元素）| <div v-if="isShow">显示内容</div>                  |
| v-show                | 条件显示（切换 DOM 元素 display 属性）| <div v-show="isShow">显示内容</div>                |
| v-for                 | 列表循环渲染（需配合 key）| <li v-for="item in list" :key="item.id">{{ item.name }}</li> |
| v-model               | 表单双向数据绑定（语法糖）| <input v-model="username" type="text">            |
| v-once                | 仅渲染一次，后续数据变更不更新               | <p v-once>{{ staticMessage }}</p>                  |

#### 虚拟 DOM
**虚拟 DOM 是对真实 DOM 的轻量级内存描述（本质是一个 JavaScript 对象）**，Vue 会先将组件模板编译为虚拟 DOM 树，当数据发生变化时，不会直接更新真实 DOM，而是先更新虚拟 DOM，再通过「diff 算法」对比新旧虚拟 DOM 的差异，最终只将差异部分更新到真实 DOM 中。

#### 生命周期钩子
Vue 组件从「创建 → 挂载 → 更新 → 销毁」的整个过程称为「组件生命周期」，Vue 提供了一系列生命周期钩子函数，允许开发者在组件生命周期的不同阶段执行自定义逻辑（如初始化数据、请求接口、清理定时器）。

---

## 4. v-if 和 v-show 的区别？

| 对比维度       | v-if                          | v-show                       |
|----------------|-------------------------------|------------------------------|
| 底层实现       | 动态创建 / 销毁 DOM 元素              | 切换 DOM 元素的 display CSS 属性    |
| 渲染特性       | 惰性渲染（条件为 true 时才首次渲染）         | 非惰性渲染（无论条件如何，立即渲染 DOM）       |
| 初始化开销     | 条件为 false 时开销极低，true 时开销较高    | 固定开销（始终创建 DOM），开销较低          |
| 切换开销       | 高（DOM 重排 / 重绘，子组件生命周期触发）      | 极低（仅修改 CSS 样式，无 DOM 结构变化）    |
| 支持元素       | 单个元素、\<template> 标签           | 单个真实 DOM 元素（不支持 \<template>） |
| 多分支支持     | 支持 v-else-if、v-else           | 不支持，仅单一条件切换                  |
| v-for 优先级   | Vue 2 低于 v-for，Vue 3 高于 v-for | 无明确优先级（不推荐与 v-for 同元素使用）     |
| 适用场景       | 条件极少变化（如权限控制、首次加载判断）          | 条件频繁切换（如选项卡、开关显示 / 隐藏）       | 

---


## 5. Vue 组件通信方式有哪些？

| 通信方式               | 适用场景                             | 核心优势                                 | 注意事项                                     |
|------------------------|--------------------------------------|------------------------------------------|----------------------------------------------|
| Props + Emits          | 父子组件通信                         | 语法简洁、单向数据流、支持校验           | 子组件不可直接修改 Props                     |
| v-model                | 父子组件双向绑定                     | 简化 Props + Emits，语法优雅             | Vue 2 仅支持单个，Vue 3 支持多个             |
| 共同父组件中转         | 兄弟组件通信                         | 无需额外依赖、可靠稳定                   | 组件层级较深时，代码略显繁琐                 |
| Event Bus（mitt）      | 小型项目的兄弟 / 跨级组件             | 实现简单、灵活轻便                       | 大型项目易造成事件混乱，需及时取消监听       |
| provide / inject       | 跨级组件通信（祖孙）| 解决 Props 透传，简化深层通信           | 避免滥用，适合全局配置类数据传递             |
| Pinia / Vuex           | 中大型项目全局共享状态               | 状态统一管理、支持响应式、可追溯         | 小型项目引入成本过高                         |
| ref + expose           | 父子组件直接访问                     | 可直接操作子组件属性 / 方法               | 破坏组件封装性，谨慎使用                     |
| $attrs / $listeners    | 跨级组件透传属性 / 事件               | 简化透传逻辑                             | Vue 3 中 $listeners 已合并到 $attrs           |

---

## 6. Vue v-model 实现原理?
v-model 本质是 **Props 传递数据 + Emits 派发事件**的语法糖，并非全新的通信机制，其核心是通过「数据单向传递」+「事件反馈修改」实现父子组件（或表单元素）的数据双向同步。

### 一、先理解：原生表单元素的 v-model 实现（底层原理）
在原生表单元素（input、select、textarea 等）上使用 v-model，Vue 已经帮我们封装了默认的「属性绑定 + 事件监听」逻辑，无需手动实现，其底层可拆解为两步。

| 表单元素类型                                   | 默认绑定属性 | 默认绑定事件 | 核心逻辑                                                     |
|------------------------------------------------|--------------|--------------|--------------------------------------------------------------|
| 文本输入框（input[type=text]/textarea）| value        | input        | 绑定 value 传递数据，监听 input 事件获取输入值并更新数据     |
| 单选框 / 复选框（input[type=radio]/[type=checkbox]） | checked      | change       | 绑定 checked 传递选中状态，监听 change 事件获取状态变更并更新数据 |
| 下拉选择框（select）| value        | change       | 绑定 value 传递选中值，监听 change 事件获取选中结果并更新数据 |

```vue
<!-- 简化写法：v-model -->
<input v-model="inputValue" />

<!-- 等价于：手动拆解 Props + 事件（语法糖还原） -->
<input :value="inputValue" @input="inputValue = $event.target.value" />
```
核心特点
  - 无需手动处理属性和事件，Vue 自动封装默认逻辑；
  - 实现「视图输入 → 数据更新」和「数据更新 → 视图同步」的双向同步；
  - 支持修饰符（如 v-model.trim 去空格、v-model.number 转为数字），简化表单处理。


### 二、Vue 封装的 v-model 实现原理 
在自定义组件上使用 v-model，需要手动实现「父组件传递 Props」和「子组件派发事件」的对应逻辑，Vue 3 对 v-model 进行了大幅优化，支持自定义绑定属性和多个 v-model 绑定，灵活性更高。

#### 场景 1：单个 v-model 绑定（默认配置）

1. 核心规则（Vue 3 默认）
   - 父组件通过 v-model 绑定数据，等价于向子组件传递 modelValue Props；
   - 子组件需要通过 update:modelValue 事件派发数据变更，通知父组件更新源数据；
   - 子组件需通过 defineProps 声明 modelValue，通过 defineEmits 声明 update:modelValue。

#### 场景 2：单个 v-model 绑定（自定义属性名，非默认 modelValue）
Vue 3 支持自定义 v-model 的绑定属性名，无需局限于 modelValue，通过 v-model:属性名 即可实现，适用于语义化更强的场景。
1. 核心规则
   - 父组件使用 v-model:自定义属性名 绑定数据（如 v-model:username）；
   - 子组件对应接收 自定义属性名 Props（如 username）；
   - 子组件对应派发 update:自定义属性名 事件（如 update:username）。

#### 场景 3：多个 v-model 绑定（Vue 3 新增特性）
Vue 3 支持在同一个自定义组件上绑定多个 v-model，每个 v-model 对应不同的属性和事件，适用于需要同时双向绑定多个数据的场景（如表单组件同时绑定用户名、密码）。
1. 实现原理
   - 每个 v-model:自定义属性名 对应一组「Props + 事件」，相互独立，互不干扰。

---











