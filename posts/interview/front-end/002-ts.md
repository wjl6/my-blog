---
title: "002-ts.md"
date: 2026-01-11 18:00:46
tags: []
---

## 1. ts 和 js有什么区别？
TypeScript 是 JavaScript 的超集（Superset），它完全兼容 JavaScript 的所有语法和功能，同时在其基础上添加了「静态类型系统」等核心扩展，最终 TS 代码需要编译（转译）为 JS 代码才能在浏览器 / Node.js 环境中运行。

### 1. 类型系统：静态类型（TS）vs 动态类型（JS）
这是 TS 和 JS 最本质、最核心的区别，直接决定了两者的开发体验、代码质量和维护成本。

**（1）JavaScript：动态类型，运行时校验**
- 核心特点：**变量的类型无需提前声明，且类型可以在运行时动态改变（赋值什么类型，变量就是什么类型）**。
- 校验时机：**仅在代码运行时才会进行类型校验，编译 / 编写阶段无法发现类型错误。**
```js
// 1. 变量无需声明类型，直接赋值
let num = 10; 
console.log(num + 5); // 正常输出：15

// 2. 运行时可以动态修改变量类型（合法，但容易出问题）
num = "Hello JS"; 
console.log(num + 5); // 运行时才报错/出现意外结果："Hello JS5"（无语法错误，逻辑错误）
```
- 痛点：大型项目中，类型混乱容易导致隐藏的逻辑错误，且难以排查；代码可读性差，他人无法快速知晓变量 / 函数的预期类型。

**（2）TypeScript：静态类型，编译时校验**
- 核心特点：**要求变量 / 函数 / 对象等提前声明类型（或通过 TS 类型推导自动确定类型），且类型一旦确定（除非显式指定联合类型等），无法随意改变。**
- 校验时机：**在代码编译（转译为 JS）阶段就会进行严格的类型校验**，不通过类型校验则无法完成编译，更无法运行。
```js
// 1. 声明变量时指定类型（: number 表示变量 num 是数字类型）
let num: number = 10; 
console.log(num + 5); // 正常编译，输出：15

// 2. 尝试修改为非数字类型，编译阶段直接报错（无法通过编译，更不会运行）
num = "Hello TS"; 
// 报错信息：Type '"Hello TS"' is not assignable to type 'number'.
```
- 优势：
  - 提前暴露类型错误，避免运行时踩坑，大幅提升代码健壮性；
  - 明确的类型标注让代码可读性更高，便于团队协作和大型项目维护；
  - 支持 IDE 智能提示（如变量方法补全、类型提示），提升开发效率。

### 2. 语言功能：TS 扩展 JS，提供更多高级特性
TS 作为 JS 的超集，不仅添加了静态类型系统，还提供了许多 JS（尤其是 ES5/ES6 早期版本）不具备的高级语法特性，这些特性最终会被编译为兼容的 JS 代码运行。
- 核心扩展特性：接口（interface）、类型别名（type）、泛型（Generic）、枚举（enum）、抽象类（abstract class）等。

```js
// 定义接口：约束 User 对象的结构（必须包含 name: string，age: number）
interface User {
  name: string;
  age: number;
}

// 定义函数：参数必须符合 User 接口结构
function printUserInfo(user: User) {
  console.log(`姓名：${user.name}，年龄：${user.age}`);
}

// 正确调用：符合接口约束
printUserInfo({ name: "张三", age: 25 });

// 错误调用：缺少 age 属性，编译阶段报错
printUserInfo({ name: "李四" });
// 报错信息：Property 'age' is missing in type '{ name: string; }' but required in type 'User'.
```


---

## 2. es6有哪些新特性？
ECMAScript（ES）：是 JavaScript 语言的**标准化规范**（由 ECMA 国际组织制定），JavaScript 是 ECMAScript 的实现和扩展（还包含 DOM、BOM 等浏览器特有 API）。

### 1. let 和 const：块级作用域变量声明（替代 var）
ES5 中 var 存在「变量提升、无块级作用域、可以重复声明」等痛点，ES6 引入 let 和 const 解决了这些问题，成为现代开发的首选变量声明方式。

| 声明方式 | 作用域               | 变量提升                     | 重复声明 | 重新赋值                                       | 典型场景                                   |
|----------|----------------------|------------------------------|----------|------------------------------------------------|--------------------------------------------|
| var      | 函数级 / 全局        | ✅ 是                        | ✅ 允许   | ✅ 允许                                        | 兼容老旧项目（不推荐）                     |
| let      | 块级（{} 包裹）| ❌ 否（存在「暂时性死区」）| ❌ 禁止   | ✅ 允许                                        | 声明需要后续修改的变量（如循环变量、局部变量） |
| const    | 块级（{} 包裹）| ❌ 否（存在「暂时性死区」）| ❌ 禁止   | ❌ 禁止（引用类型仅禁止地址修改，属性可改）| 声明常量、无需修改的变量（如配置项、引用类型对象） |

### 2. 箭头函数（=>）：简化函数语法，改变 this 指向
箭头函数是 ES6 中最常用的语法糖之一，用于简化函数声明，同时解决了 ES5 中 this 指向混乱的问题。

核心特性
- 语法简化：无参数 / 单个参数 / 多个参数的写法灵活，函数体只有一行代码时可省略 {} 和 return；
- this 绑定：箭头函数没有自己的 this，其 this 继承自「定义时的外层作用域」（而非调用时），永久绑定，无法通过 call/apply/bind 修改；
- 限制：不能作为构造函数（无法使用 new），没有 arguments 对象，没有 prototype 属性。
```js
// 1. 语法简化
const sum = (a, b) => a + b; // 等价于：function sum(a, b) { return a + b; }
console.log(sum(1, 2)); // 输出：3

const sayHello = name => `Hello, ${name}!`; // 单个参数可省略 ()
console.log(sayHello("Vue")); // 输出：Hello, Vue!

// 2. this 绑定（核心优势）
const obj = {
  name: "ES6",
  fn1: function() {
    // ES5 函数：this 指向调用者（obj）
    setTimeout(function() {
      console.log(this.name); // 输出：undefined（this 指向 window）
    }, 100);
  },
  fn2: function() {
    // 箭头函数：this 继承外层作用域（fn2 的 this，即 obj）
    setTimeout(() => {
      console.log(this.name); // 输出：ES6（符合预期）
    }, 100);
  }
};
obj.fn1();
obj.fn2();
```

### 3. 解构赋值：快速提取对象 / 数组的属性 / 元素
解构赋值是一种快速从「对象」或「数组」中提取数据的语法，简化了变量赋值的繁琐代码，大幅提升开发效率。

核心分类
- 数组解构：按「索引顺序」提取元素，支持默认值、剩余参数；
- 对象解构：按「属性名」匹配提取，支持默认值、属性重命名、剩余参数。

```js
// 1. 数组解构
const arr = [1, 2, 3];
const [a, b, c] = arr; // 按索引解构
console.log(a, b, c); // 输出：1 2 3

const [x, , z] = arr; // 跳过第二个元素
const [m, n, ...rest] = [4, 5, 6, 7]; // 剩余参数（... 扩展运算符）
console.log(rest); // 输出：[6, 7]

const [p = 0, q = 0] = [8]; // 默认值
console.log(q); // 输出：0

// 2. 对象解构（开发中更常用）
const user = { name: "张三", age: 25, gender: "男" };
const { name, age } = user; // 按属性名解构
console.log(name, age); // 输出：张三 25

const { gender: sex, address = "未知" } = user; // 属性重命名 + 默认值
console.log(sex, address); // 输出：男 未知

const { name: userName, ...other } = user; // 剩余参数
console.log(other); // 输出：{ age: 25, gender: "男" }
```

### 4. 模板字符串：简化字符串拼接，支持多行文本
ES6 引入反引号（`）作为模板字符串的标识，解决了 ES5 字符串拼接繁琐、不支持多行文本的问题。

核心特性
- 支持多行文本：直接换行即可，无需使用 \n 转义；
- 变量插值：通过 ${变量/表达式} 直接嵌入变量或 JavaScript 表达式；
- 支持标签模板：可用于高级字符串处理（如转义 HTML、格式化数据）。

### 5. 类（Class）：面向对象编程的标准化语法
ES5 中通过「构造函数 + 原型链」实现面向对象，语法繁琐且不直观。ES6 引入 class 关键字，提供了更接近传统面向对象语言（Java、C++）的类语法，本质是「构造函数 + 原型链」的语法糖，但更清晰、更易维护。

核心特性
- 关键字：class（定义类）、constructor（构造方法，实例化时自动执行）、extends（继承）、super（调用父类构造方法 / 方法）；
- 支持定义实例方法、静态方法（static 关键字）、实例属性、静态属性；
- 支持继承：解决了 ES5 原型链继承的繁琐问题。

### 6. 模块化（Module）：解决大型项目代码组织问题
ES5 没有原生模块化规范，前端开发依赖 CommonJS（Node.js）、AMD（RequireJS）等第三方规范。ES6 引入原生模块化规范，将每个 .js 文件视为一个模块，支持「导出（export）」和「导入（import）」，解决了大型项目中代码冗余、命名冲突、依赖混乱等问题。

核心语法
- 导出（export）：分为「命名导出」和「默认导出」，一个模块可以有多个命名导出，仅能有一个默认导出；
- 导入（import）：对应导出方式，导入命名导出需用 {}，导入默认导出可直接命名，支持按需导入、整体导入。

### 7. 其他常用核心新特性（简要说明 + 示例）
#### （1）Promise：解决异步回调地狱
用于处理异步操作（如接口请求、定时器），替代传统的多层回调函数，让异步代码更清晰、更易维护，是现代前端异步编程的基础（axios、async/await 均基于 Promise）。

#### （2）Set/Map：新的数据结构
- Set：无序、不重复的集合，用于去重、快速判断元素是否存在；
- Map：键值对集合（键可以是任意类型，而非仅字符串），替代传统对象的局限性。

#### （3）扩展运算符（...）：展开 / 合并数据
用于展开数组、对象，或合并数据，语法简洁，替代 ES5 的 apply、concat 等方法。


---


