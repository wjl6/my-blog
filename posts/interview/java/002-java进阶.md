---
title: "002-java进阶.md"
date: 2025-12-27 18:36:44
tags: []
---

## 1. 线程池中线程是如何流转的？

```text
【任务提交】 → 1.判断核心线程是否已满 → 2.核心线程执行任务/新创建核心线程 → 3.核心线程满则任务入队 → 4.队列满则创建非核心线程 → 5.线程总数满则执行拒绝策略 → 6.线程执行完任务后复用/销毁
```

- 对核心线程：**如果队列里没有任务，会一直阻塞在队列**的take()方法上，永久等待新任务，不会退出循环，所以核心线程永久存活、不会销毁；
- 对非核心线程：如果队列里没有任务，会阻塞在队列的poll(keepAliveTime)方法上，等待指定的时间，如果超时还取不到任务，就退出循环，线程被销毁；


```text
优先级1：复用【已创建的空闲线程】 → 优先级2：创建【新的核心线程】 → 优先级3：任务进入阻塞队列排队 → 优先级4：创建【非核心线程】 → 优先级5：执行拒绝策略
```

---

## 2. java中有哪些元注解？
元注解（Meta Annotation），是指「用于修饰其他注解的注解」

| 注解名称       | 核心作用                                                         | 核心属性 / 枚举值                                                                 | 关键说明与适用场景                                                                                                 |
|----------------|------------------------------------------------------------------|----------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------|
| **@Target**        | 约束自定义注解的适用范围（可作用于哪些 Java 元素）| 仅有 value()，类型为 ElementType[]（常用枚举值：TYPE/METHOD/FIELD/PARAMETER 等）| 1. 不指定时，注解可作用于所有支持的 Java 元素；<br>2. 框架注解均明确指定适用范围（如 @Service 标注为 TYPE）|
| **@Retention**     | 指定自定义注解的生命周期（保留策略）| 仅有 value()，类型为 RetentionPolicy（3 个枚举值：SOURCE/CLASS/RUNTIME）| 1. 默认值为 CLASS；<br>2. 框架开发（如 Spring/MyBatis）核心使用 RUNTIME（支持反射解析）；<br>3. SOURCE 仅用于编译期检查（如 @Override）|
| @Documented    | 标记注解是否被 Javadoc 文档化                                    | 无任何属性，仅作为标记使用                                                       | 1. 仅对 CLASS/RUNTIME 保留策略的注解有效；<br>2. 适用于对外暴露的 API 注解，方便使用者查阅文档                     |
| @Inherited     | 标记注解是否能被子类继承                                         | 无任何属性，仅作为标记使用                                                       | 1. 仅对作用于类（ElementType.TYPE）的注解有效；<br>2. 对接口实现、方法 / 字段注解无效；<br>3. 子类手动添加注解会覆盖父类继承的注解 |
| @Repeatable    | 标记注解是否可在同一元素上重复使用（Java 8 新增）| 仅有 value()，类型为「容器注解的 class 对象」| 1. 需配合「容器注解」使用（存储多个重复注解实例）；<br>2. 容器注解的 @Target/@Retention 需与可重复注解保持一致；<br>3. 反射可通过 getAnnotationsByType() 获取注解数组 |
| @AliasFor（Spring） | 指定注解的属性别名，实现属性值复用 / 传递                        | 仅有 value()，指定互为别名的属性名称（如 value() ↔ path()）| 1. 互为别名的属性赋值效果一致，获取值时返回相同结果；<br>2. 广泛用于 Spring 注解（如 @RequestMapping），简化注解使用 |

### @Target：约束自定义注解的「适用范围」

- 核心作用  
指定自定义注解可以作用于哪些 Java 元素（如类、方法、字段、参数等），如果不指定 @Target，自定义注解可以作用于所有支持的 Java 元素。
- 核心属性  
仅有一个属性 value()，类型为 ElementType[]（数组，支持指定多个适用范围），ElementType 是枚举类型，常用枚举值如下：

| ElementType 枚举值 | 适用范围                                                       | 示例                                          |
|--------------------|----------------------------------------------------------------|-----------------------------------------------|
| TYPE               | 类、接口、枚举、注解                                           | @Service、@Controller 作用于类                |
| METHOD             | 方法                                                           | @GetMapping、@Override 作用于方法              |
| FIELD              | 字段、枚举常量                                                 | @Autowired、@Value 作用于字段                  |
| PARAMETER          | 方法参数                                                       | @RequestParam 作用于接口方法参数              |
| CONSTRUCTOR        | 构造方法                                                       | 自定义注解作用于类的构造方法                  |
| ANNOTATION_TYPE    | 注解（仅用于修饰其他注解，即元注解的元注解）                   | @Target 自身就作用于 ANNOTATION_TYPE          |
| LOCAL_VARIABLE     | 局部变量                                                       | 自定义注解作用于方法内的局部变量              |
| PACKAGE            | 包                                                             | 自定义注解作用于 package-info.java 中的包     |


### @Retention：指定自定义注解的「生命周期（保留策略）」
- 核心作用  
指定自定义注解在哪个阶段被保留，即注解的有效范围，这直接决定了注解是否能被反射机制获取（关键影响框架的注解解析逻辑）。
- 核心属性  
仅有一个属性 value()，类型为 RetentionPolicy（枚举类型，仅 3 个枚举值，优先级从低到高）：

| RetentionPolicy 枚举值 | 保留阶段                     | 核心说明                                                                 | 是否可被反射获取 |
|------------------------|------------------------------|--------------------------------------------------------------------------|------------------|
| SOURCE                 | 源码阶段（编译前）           | 注解仅保留在 Java 源码中，编译为 class 文件后，注解被丢弃（消失）         | ❌ 否            |
| CLASS（默认值）| 类文件阶段（编译后，运行前） | 注解保留在 class 文件中，但 JVM 加载类时，注解不会被加载到内存中           | ❌ 否            |
| RUNTIME                | 运行时阶段（JVM 加载后）     | 注解保留在 class 文件中，且 JVM 加载类时，注解被加载到内存中，一直有效到应用运行结束 | ✅ 是            |

- SOURCE 注解通常用于「编译期检查」，如 JDK 自带的 @Override（检查方法是否重写父类方法）、@SuppressWarnings（抑制编译警告），编译后无需保留；
- RUNTIME 注解是「框架开发的核心」，如 Spring 的 @Autowired、@Service，MyBatis 的 @Mapper，都需要在运行时通过反射解析注解信息，实现依赖注入、Bean 扫描等功能

### @Documented：标记注解是否被「文档化」

- 核心作用  
指定自定义注解是否会被 Javadoc 工具提取到 API 文档中，如果添加了 @Documented，生成 Javadoc 文档时，被该注解修饰的元素会显示注解信息；否则，注解信息不会出现在文档中。
- 关键说明  
  - 无任何属性，仅作为标记使用；  
  - 仅对 @Retention(RetentionPolicy.RUNTIME) 或 @Retention(RetentionPolicy.CLASS) 的注解有效（SOURCE 注解编译后丢弃，无法被文档化）；
  - 通常用于「对外暴露的 API 注解」，方便使用者通过文档了解注解的用途。

### @Inherited：标记注解是否被「继承」

- 核心作用  
指定自定义注解是否能被子类继承—— 如果父类被添加了该注解，且注解标记了 @Inherited，那么子类会自动继承该注解（无需手动添加）；否则，子类不会继承父类的注解。
- 关键说明
  - 无任何属性，仅作为标记使用；
  - 仅对「作用于类（ElementType.TYPE）」的注解有效，对方法、字段等注解无效；
  - 子类继承的是「父类的注解实例」，如果子类手动添加了该注解，会覆盖父类的注解信息；
  - 仅对「类的继承」有效，对「接口的实现」无效（子类实现接口，不会继承接口上的注解）。

### @Repeatable：标记注解是否「可重复使用」
- 核心作用  
指定自定义注解是否可以在同一个 Java 元素上重复添加多次（Java 8 新增），解决了「同一个元素无法多次使用同一个注解」的痛点。
- 关键说明
  - 仅有一个属性 value()，类型为「容器注解的 class 对象」—— 可重复注解需要配合一个「容器注解」使用，容器注解用于存储多个重复注解的实例；
  - 容器注解需要满足：@Target 和 @Retention 与可重复注解保持一致（或更宽泛），且包含一个返回「可重复注解数组」的属性（通常命名为 value()）；
  - 反射获取重复注解时，可通过 getAnnotationsByType() 直接获取注解数组，或通过 getAnnotation() 获取容器注解。

### Spring 的 @AliasFor
- 核心作用  
指定注解的「属性别名」，即两个属性互为别名，赋值时两者效果一致，获取注解属性时，两者返回相同的值（解决注解属性复用、传递的问题）。

```java
// 自定义注解 @MyRequestMapping，使用 @AliasFor 定义属性别名
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyRequestMapping {
    // 定义 value() 和 path() 互为别名
    @AliasFor("path")
    String[] value() default {};
    
    @AliasFor("value")
    String[] path() default {};
    
    String method() default "GET";
}

// 使用注解：value() 和 path() 赋值效果一致
public class MyController {
    // 方式 1：赋值给 value()
    @MyRequestMapping(value = "/user/list")
    public void getUserList() {}
    
    // 方式 2：赋值给 path()（与方式 1 效果一致）
    @MyRequestMapping(path = "/user/add", method = "POST")
    public void addUser() {}
}
```
---

## 3. 什么是反射？有什么作用

### 什么是反射？
#### 1. 核心定义
- 反射是指程序在运行时（Runtime），能够自我检测、获取自身类的完整信息（类名、属性、方法、注解、构造器等），并且可以动态操作类的对象、调用方法、修改属性值的一种能力。
- 简单来说：正常开发是「编译期确定类的使用」（先知道类，再创建对象、调用方法），而反射是「运行期发现类的信息、操作类的成员」（运行时才知道要操作的类是谁，动态完成所有操作）。
#### 2. 关键前提与核心类
- 关键前提：Java 中所有类在运行时都会被封装为 java.lang.Class 类的实例（每个类仅有一个 Class 对象），反射的所有操作都围绕这个 Class 对象展开。
- 核心 API（位于 java.lang.reflect 包下）：
  - Class：获取类的核心入口，承载类的所有元信息；
  - Field：描述类的属性（成员变量），支持动态获取 / 修改属性值；
  - Method：描述类的方法，支持动态调用方法；
  - Constructor：描述类的构造器，支持动态创建对象；
  - Annotation：描述类的注解，支持动态解析注解信息。
#### 3. 直观对比：普通开发 vs 反射开发

```java
// 1. 编译期已明确要使用的类（UserService）
// 2. 直接创建对象、调用方法
UserService userService = new UserService();
String result = userService.getUserInfo(1001);


// 1. 运行时通过类名获取 Class 对象（无需编译期知道 UserService）
Class<?> clazz = Class.forName("com.example.service.UserService");

// 2. 动态创建对象
Object userService = clazz.newInstance();

// 3. 动态获取方法、调用方法
Method method = clazz.getMethod("getUserInfo", Integer.class);
Object result = method.invoke(userService, 1001);
```

### 反射的核心作用

#### 1. 作用一：运行时动态获取类的完整元信息
无需提前知晓类的结构，在运行时可以获取类的类名、父类、接口、属性、方法、构造器、注解等所有元信息，这是框架解析配置、实现自动扫描的基础。
- 实战场景
  - Spring 启动时扫描 @Service、@Controller 注解：通过反射遍历指定包下的所有类，获取类上的注解信息，判断是否需要将其创建为 Bean 放入 IoC 容器；
  - MyBatis 解析 @Mapper 注解和 @Select 注解：通过反射获取接口方法上的注解信息，构建 SQL 执行逻辑。

#### 2. 作用二：动态创建对象（无需 new 关键字）
通过反射获取类的构造器（Constructor），可以在运行时动态创建对象，无需使用 new 关键字，支持创建无参对象和有参对象，这是 IoC 容器自动创建 Bean 的核心原理。
- 实战场景
  - Spring IoC 容器：根据扫描到的类信息，通过反射动态创建 Bean 实例，无需开发者手动 new 对象，实现对象的统一管理；
  - 序列化 / 反序列化（如 JSON 解析）：Jackson、FastJSON 等框架通过反射，将 JSON 数据转换为对应的 Java 对象（动态创建对象，再为属性赋值）。

#### 3. 作用三：动态调用方法（包括私有方法）
通过反射获取类的方法（Method），可以在运行时动态调用对象的方法，包括**公共方法（public）和私有方法（private）（通过 setAccessible(true) 打破访问权限限制）**，这是 AOP 动态代理、远程调用的核心原理。
- 实战场景
  - Spring AOP：通过反射动态调用目标方法，同时在方法执行前后植入横切逻辑（日志、权限、事务等）；
  - 动态代理（JDK 动态代理）：通过反射调用被代理对象的方法，实现方法的增强；
  - 测试框架（如 JUnit）：通过反射调用被测试类的测试方法（@Test 注解标记的方法）。

#### 4. 作用四：动态修改属性值（包括私有属性）
通过反射获取类的属性（Field），可以在运行时动态获取和修改对象的属性值，同样支持**打破私有属性的访问权限限制**，这是框架**实现属性注入、配置绑定的核心原理**。
- 实战场景
  - **Spring 依赖注入**：通过反射将 IoC 容器中的 Bean 动态注入到目标对象的私有属性中（如 @Autowired 注解的字段）；
  - **配置文件绑定**：Spring Boot 将 application.yml 中的配置项，通过反射动态绑定到 @ConfigurationProperties 注解类的属性中。

#### 5. 作用五：实现框架的灵活可扩展（反射的核心价值体现）
反射的前 4 个作用最终都服务于这一点：**框架通过反射实现「配置驱动」，让开发者无需修改框架源码，只需通过配置（注解、XML 等）即可实现自定义功能，大幅提升框架的灵活性和可扩展性。**

| 框架 / 技术                | 反射的具体应用                                                                 |
|---------------------------|--------------------------------------------------------------------------------|
| Spring/Spring Boot        | 1. 扫描注解创建 Bean；2. 依赖注入（@Autowired）；3. 声明式事务（@Transactional）；4. 配置绑定 |
| MyBatis                   | 1. 解析 @Mapper 接口；2. 解析 SQL 注解（@Select/@Insert）；3. 结果集映射（将查询结果封装为 Java 对象） |
| 序列化框架（Jackson/FastJSON） | 1. 动态创建对象；2. 动态读写对象属性，实现 JSON 与 Java 对象的转换                 |
| 测试框架（JUnit/TestNG）  | 1. 解析 @Test 注解，动态调用测试方法；2. 初始化测试对象                           |

### 反射的优缺点补充（客观认知）
#### 1. 优点
- 极高的灵活性：打破编译期约束，支持运行时动态操作，是框架开发的基石；
- 解耦：无需硬编码依赖具体类，通过配置即可实现功能扩展，提升项目可维护性；
- 简化开发：框架通过反射封装复杂逻辑，开发者无需关注底层实现，专注于业务开发。
#### 2. 缺点
- 性能损耗：反射需要在运行时解析类信息、打破访问权限、动态调用方法，比直接调用的性能略低（但在企业级开发中，这种损耗几乎可以忽略，框架会通过缓存优化）；
- 安全性问题：反射可以访问和修改私有成员，可能破坏类的封装性，带来安全风险；
- 可读性降低：反射代码比普通代码更复杂，难以调试和维护，不宜在业务代码中过度使用。

---

## 4. jdk动态代理为什么要求目标对象必须实现至少一个接口?

### JDK 动态代理核心原理
- **底层依赖**：基于 Java 反射机制的 java.lang.reflect.Proxy 类和 java.lang.reflect.InvocationHandler 接口实现，无需第三方依赖（JDK 自带）。
- **核心逻辑**：
  - 运行时动态生成一个代理类（继承自 Proxy，并实现目标对象的所有接口）；
  - 代理类的所有接口方法调用，都会被转发到 InvocationHandler 的 invoke() 方法中；
  - 在 invoke() 方法中，可以实现「增强逻辑」（如日志、权限校验），再通过反射调用目标对象的原始方法。
- **为什么要求目标对象实现接口**：
JDK 动态代理生成的代理类已经继承了 java.lang.reflect.Proxy 类，而 Java 是「单继承」语言，无法再继承其他类，因此只能通过「实现目标对象的接口」来保证代理类与目标对象具有相同的方法签名，从而实现对目标对象的代理。


---












