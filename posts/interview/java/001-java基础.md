---
title: "001-java基础.md"
date: 2025-12-26 15:24:45
tags: []
---

## 一、Java 基础语法与面向对象

### 1. Java 是值传递还是引用传递？
**结论：Java 只有值传递**

- 基本类型：传递的是值的拷贝
- 引用类型：传递的是“引用地址的拷贝”

👉 面试陷阱：  
即使是对象，方法内修改引用指向，不会影响原对象引用

---

### 2. 面向对象三大特性？
- **封装**：隐藏实现细节，通过接口暴露能力
- **继承**：复用父类逻辑，is-a 关系
- **多态**：父类引用指向子类对象，运行时绑定

---

### 3. 重载（Overload）和重写（Override）的区别？

| 维度 | 重载 | 重写 |
|----|----|----|
| 发生位置 | 同一个类 | 父子类 |
| 方法名 | 相同 | 相同 |
| 参数列表 | 不同 | 必须相同 |
| 访问权限 | 无要求 | 不能更严格 |
| 绑定时机 | 编译期 | 运行期 |

---

### 4. 接口和抽象类的区别？

| 维度 | 接口 | 抽象类 |
|----|----|----|
| 多继承 | 支持 | 不支持 |
| 成员变量 | 常量 | 普通变量 |
| 方法 | 默认 public | 任意 |
| 使用场景 | 能力定义 | 模板设计 |

---



### 5. final 关键字的作用？
- final 类：不能被继承
- final 方法：不能被重写
- final 变量：不可变

---




## 二、集合框架


### 1. ArrayList 和 LinkedList 区别？

| 维度 | ArrayList | LinkedList |
|----|----|----|
| 底层 | 动态数组 | 双向链表 |
| 随机访问 | 快 | 慢 |
| 插入删除 | 慢 | 快 |
| 内存占用 | 少 | 多 |

---

### 2. HashMap 的底层实现原理？

- JDK 1.8 之后：**数组 + 链表 + 红黑树**
- 默认初始容量：16
- 负载因子：0.75
- 链表长度 ≥ 8 且数组长度 ≥ 64 → 转红黑树

---

### 3. HashMap 为什么线程不安全？
- 并发 put 可能导致：
    - 数据覆盖
    - 死循环（JDK 1.7）
- 多线程环境应使用：
    - ConcurrentHashMap
    - 或加锁

---

### 4. ConcurrentHashMap 如何保证线程安全？
- JDK 1.8：
    - CAS + synchronized
    - 锁粒度为桶级别
- 不再使用 Segment 分段锁

---

### 5. HashSet 如何保证元素唯一？
- 底层使用 HashMap
- key 作为元素，value 为固定 Object
- 依赖：
    - hashCode()
    - equals()

---

## 三、异常机制（必考）

### 1. Exception 和 Error 的区别？
- Error：JVM 层级错误（OOM、StackOverflow）
- Exception：程序可处理异常

---

### 2. 受检异常和非受检异常？

- 受检异常（Checked）：
    - 编译期强制处理
    - IOException
- 非受检异常（RuntimeException）：
    - 运行期异常
    - NullPointerException

---

### 3. try-catch-finally 执行顺序？
1. try
2. catch（如有异常）
3. finally（几乎一定执行）

⚠️ finally 中 return 会覆盖 try 的 return（面试陷阱）

---

## 四、JVM 基础

### 1. JVM 内存结构？

- 程序计数器
- 虚拟机栈
- 本地方法栈
- 堆
- 方法区（元空间）

---

### 2. 堆和栈的区别？

| 维度 | 堆 | 栈 |
|----|----|----|
| 存储 | 对象 | 局部变量 |
| 线程 | 共享 | 私有 |
| GC | 是 | 否 |

- **核心属性**：堆是线程共享的 “大仓库”，栈是线程私有的 “小工作台”；
- **存储与管理**：堆存对象实例（GC 回收），栈存方法执行的临时数据（自动释放）；
- **性能特征**：栈访问速度快、无碎片，堆空间大但访问慢、易产生碎片；
- **关键考点**：对象引用在栈、对象本身在堆，这是理解两者区别的核心。

---

### 3. 垃圾回收如何判断对象已死？
- 引用计数法（已废弃, 无法解决对象之间循环引用的问题）
- 可达性分析（GC Roots）

---

### 4. GCRoots 包含哪些对象？
- 虚拟机栈（栈帧）中的**局部变量表引用的对象**（如方法中的 User user = new User() 里的 user）；
- 方法区中**静态变量引用的对象**（如 public static User staticUser = new User()）；
- 方法区中**常量引用的对象**（如 public static final User CONST_USER = new User()）；
- 本地方法栈中 **Native 方法引用的对象**（如 JNI 调用的 C++ 对象）；
- **JVM 内部的核心对象**（如 Class 对象、异常对象、系统类加载器）。

---

### 5. 引用类型对判定结果的影响
| 引用类型 | 特点 | 回收时机 |
|----|----|----|
|强引用（Strong）	| 最普通的引用（如 User user = new User()）	| 只要强引用存在，对象绝对不回收
|软引用（Soft）	| 用 SoftReference 包装，用于缓存	        | 内存不足时才会回收
|弱引用（Weak）	| 用 WeakReference 包装，用于临时缓存	| 下次 GC 时一定会回收
|虚引用（Phantom）| 用 PhantomReference 包装，仅用于跟踪对象回收，不能通过它获取对象	|随时可回收，仅作为回收通知
---



### 6. 常见 GC 算法？
- 标记-清除
- 标记-整理
- 标记-复制算法

---

## 五、并发与多线程（高频）

### 1. 线程的创建方式？
- 继承 Thread 重写 run() 方法
- 实现 Runnable 实现 Runnable 接口的 run() 方法（定义任务）
- 实现 Callable + FutureTask
- 线程池（推荐）

---

### 2. synchronized 和 ReentrantLock 区别？

> 可重入锁的核心是 **“线程可重复获取自身已持有的锁”**，本质通过 “记录持有线程 + 重入次数” 实现，避免自死锁

| 对比维度         | synchronized                                                                 | ReentrantLock                                                                 |
|------------------|------------------------------------------------------------------------------|-------------------------------------------------------------------------------|
| 实现层面         | JVM 内置关键字（底层通过 monitorenter/monitorexit 指令实现）                  | JDK 类（java.util.concurrent.locks，基于 AQS 框架实现）                       |
| 锁的获取 / 释放  | 隐式：加锁（进入同步块 / 方法）、释放（退出块 / 方法 / 异常）由 JVM 自动完成  | 显式：需手动调用 lock() 加锁、unlock() 释放（必须在 finally 中释放，否则易死锁） |
| 可重入性         | 支持（同一线程可多次获取同一把锁，如递归调用同步方法）                        | 支持（默认非公平锁，可指定公平锁），且可通过 getHoldCount() 获取重入次数       |
| 公平性           | 非公平锁（JVM 优先唤醒已等待的线程，但无严格顺序）                            | 支持公平 / 非公平锁（构造函数指定 new ReentrantLock(true) 为公平锁）          |
| 锁超时           | 不支持：线程获取锁时会一直阻塞，无法设置超时                                  | 支持：tryLock(long timeout, TimeUnit unit) 可设置超时，超时后放弃获取锁，避免死锁 |
| 可中断性         | 不支持：等待锁的线程无法被中断，只能一直等或抛出异常                          | 支持：lockInterruptibly() 可中断等待锁的线程（调用 thread.interrupt() 触发）   |
| 条件变量（Condition） | 仅支持 Object 的 wait()/notify()/notifyAll()，一个锁只能对应一个等待队列      | 支持多个 Condition：newCondition() 创建多个条件队列，可精准唤醒指定线程（如生产者 - 消费者模型） |
| 锁状态查询       | 无 API：无法查询锁是否被持有、等待线程数等                                    | 支持：isLocked()（是否被持有）、isHeldByCurrentThread()（当前线程是否持有）、getQueueLength()（等待线程数） |
| 性能             | Java 6 后优化（偏向锁、轻量级锁、重量级锁），低竞争时与 ReentrantLock 接近，高竞争时略差 | 高竞争场景下性能更稳定，底层 AQS 自旋 + 阻塞机制更高效                        |
| 使用复杂度       | 简单：无需手动释放，代码简洁，不易出错                                        | 复杂：需手动释放锁（finally 必须写），语法繁琐，易因遗漏 unlock() 导致死锁     |




---

### 3. volatile 的作用？
- **核心作用**：volatile 保证变量的可见性、禁止指令重排序，但不保证原子性；
- **核心原理**：通过内存屏障实现可见性和有序性，写变量刷主存、读变量读主存；
- **使用场景**：状态标记位、DCL 单例、简单变量读写；复合操作需配合原子类 / 锁；
- 对比 synchronized：volatile 是轻量级同步，无锁开销，但功能弱；synchronized 功能全，但有锁开销。

---

### 4. 线程池核心参数？
- corePoolSize    | 常驻核心线程数
- maximumPoolSize | 允许创建的最大线程数：核心线程 + 临时线程的总数上限，决定线程池的最大并发能力
- workQueue | 临时任务队列（ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue）
- keepAliveTime | 临时线程的存活时间
- unit | 时间单位
- rejectedExecutionHandler | 拒绝策略
- threadFactory | 线程工厂

> 拒绝策略（RejectedExecutionHandler） 是指：**当线程池的任务队列已满、且已达到最大线程数**（maximumPoolSize）时，新提交的任务无法被处理，线程池会触发预设的 “拒绝逻辑”—— 这是线程池保护系统资源、避免过载的核心机制。

| 拒绝策略类          | 核心逻辑                                                                 | 适用场景                                   | 风险点                                       |
|---------------------|--------------------------------------------------------------------------|--------------------------------------------|----------------------------------------------|
| AbortPolicy（默认） | 直接抛出 RejectedExecutionException 异常，拒绝任务提交                   | 核心业务（如订单支付），需要明确感知任务提交失败，及时告警 / 重试 | 未捕获异常会导致请求失败，需做好异常处理     |
| CallerRunsPolicy    | 由 “提交任务的线程” 自行执行该任务（如 Tomcat 线程池提交任务，则 Tomcat 线程自己执行） | 非核心业务（如日志采集、数据统计），允许任务降级执行，避免任务丢失 | 提交线程（如 Tomcat 主线程）被阻塞，可能影响整体吞吐量 |
| DiscardPolicy       | 静默丢弃新任务，无任何异常、无任何提示                                   | 低优先级任务（如非关键监控数据），允许丢失，不希望影响核心流程 | 任务丢失无感知，需确认业务可接受             |
| DiscardOldestPolicy | 丢弃任务队列中 “最旧的未执行任务”，尝试将新任务加入队列                   | 任务时效性强（如实时行情推送），新任务比旧任务更有价值         | 可能丢失重要的旧任务，需评估业务影响         |

---

## 六、IO 与 NIO

### 1. BIO、NIO、AIO 区别？

| 特性 | BIO (Blocking IO) 阻塞式 IO | NIO (Non-Blocking IO) 非阻塞式 IO / 多路复用 IO | AIO (Asynchronous IO) 异步 IO（NIO 2.0） |
| ---- | --------------------------- | ----------------------------------------------- | ---------------------------------------- |
| 核心模型 | 同步阻塞 | 同步非阻塞（JDK 层面）、IO 多路复用 | 异步非阻塞 |
| 核心关键词 | 阻塞、一对一（线程对应连接） | 非阻塞、多路复用、Selector（选择器） | 异步、回调、CompletionHandler |
| 线程模型 | 一个连接一个线程（线程随连接创建） | 一个线程处理多个连接（Selector 轮询就绪连接） | 无需线程轮询，完成后回调通知 |
| IO 触发时机 | 读写未就绪时，线程阻塞等待 | 读写未就绪时，线程立即返回，轮询检查就绪状态 | 读写操作提交后，线程继续执行，完成后回调 |
| 资源消耗 | 高（连接多则线程数爆炸） | 中（少量线程处理大量连接） | 低（无轮询，仅回调消耗） |
| 编程复杂度 | 简单 | 复杂（需处理 Selector、Buffer、Channel） | 最复杂（需处理回调、异常） |
| 适用场景 | 连接数少、并发低（如简单 Socket） | 连接数多、并发高（如 Netty、Tomcat 8+） | 连接数多、耗时 IO（如文件下载、大数据传输） |
| 核心组件 | Socket、ServerSocket | Channel、Buffer、Selector | AsynchronousSocketChannel、CompletionHandler |
---

### 2. NIO 的核心组件？
- Channel
- Buffer
- Selector
- 三者的关系可以概括为：Selector 监听 Channel 的就绪事件，Channel 通过 Buffer 完成数据读写。

---

## 七、Java 8 新特性

### 1. Lambda 表达式的作用？
- 简化匿名内部类
- 函数式编程

---

### 2. Stream 流的优点？
| 核心优点 | 具体解释 |
| ---- | ---- |
| 代码简洁，可读性高 | 消除传统 for 循环、if 判断的模板代码，用 “链式调用” 聚焦业务逻辑，代码行数大幅减少 |
| 支持函数式编程 | 结合 Lambda 表达式，实现 “行为参数化”（如过滤、映射逻辑可灵活传递），契合现代编程思想 |
| 支持并行处理，性能更高 | 无需手动创建线程池，通过 parallelStream() 即可实现集合的并行处理，充分利用多核 CPU |
| 惰性求值，节省资源 | 中间操作（如 filter、map）不会立即执行，只有调用终止操作（如 collect、sum）时才会执行，避免无效计算 |
| 不修改原集合，更安全 | Stream 流操作是 “无副作用” 的，不会修改原始集合的数据，避免并发修改或数据污染 |

---

### 3. Optional 解决了什么问题？
- 避免 NullPointerException
- 强制开发者处理空值

---

## 八、设计与规范

### 1. equals 和 hashCode 为什么要一起重写？
- HashMap / HashSet 依赖
- 否则可能导致重复数据

- Java 官方对 equals() 和 hashCode() 制定了必须遵守的约定，核心两条是：
> - 一致性：如果两个对象通过 equals() 判断为相等（true），那么它们的 hashCode() 必须返回相同的整数值；
> - 稳定性：如果对象用于 equals() 比较的字段没有修改，那么 hashCode() 的返回值必须保持不变（无论调用多少次）；
> - 非反向约束（补充）：两个对象的 hashCode() 相同，equals() 不一定相等（哈希冲突），但 equals() 相等则 hashCode() 必须相同。
> - 简单说：相等的对象，哈希值必须相等；哈希值相等的对象，不一定相等

---

### 2. 为什么推荐使用接口而不是实现类？
| 核心优势 | 具体解释 |
|--------|----------|
| 降低耦合度（核心） | 代码依赖 “规范” 而非 “具体实现”，修改实现类时无需改动上层调用代码，符合 “依赖倒置原则” |
| 提升代码扩展性 | 可随时替换实现类（如 ArrayList 换成 LinkedList），无需修改使用方代码 |
| 隐藏实现细节 | 调用方仅需关注接口定义的方法，无需了解实现类的内部逻辑，降低理解成本 |
| 支持多实现 / 多态 | 一个接口可有多个实现类，调用方通过接口即可适配不同实现，充分利用多态特性 |
| 便于测试和 Mock | 单元测试时可轻松替换为 Mock 实现（如用 MockList 替代真实 ArrayList），隔离依赖 |
---

### 3. Java 中的深拷贝和浅拷贝？
- 浅拷贝：复制引用
- 深拷贝：复制对象本身

---


















